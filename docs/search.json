[
  {
    "objectID": "02-data-prep.html",
    "href": "02-data-prep.html",
    "title": "2  Data Preparation",
    "section": "",
    "text": "2.1 Computational Environment\nShow the code\nlibrarian::shelf(\n  tidyverse,\n  tidymodels,\n  kableExtra,\n  patchwork,\n  skimr,\n  gridExtra,\n  gtsummary,\n  janitor,\n  corrplot,\n  sjPlot,\n  scales,\n  GGally,\n  car,\n  forcats,\n  performance,\n  glmmTMB,\n  splines,\n  mgcv,\n  DHARMa,\n  zoo,\n  ggpubr,\n  ggridges,\n  caret,\n  rstatix,\n  Metrics,\n  mice,\n  missRanger,\n  ranger,\n  cocor,\n  multcompView,\n  lmtest,\n  aod,\n  pROC,\n  naniar,\n  glue,\n  viridis,\n  parallel\n)\n\ndf &lt;- read_csv(\"data/weatherAUS.csv\") %&gt;%\n  janitor::clean_names()\n\nsource(here::here(\"utils.R\"))\nThe package selection reflects the specific demands of meteorological data analysis. The core wrangling and visualisation toolkit (tidyverse, janitor, kableExtra) handles routine data manipulation. The modelling stack (glmmTMB, DHARMa, splines, mgcv) is assembled for the zero-inflated mixed-effects framework documented in later chapters. The imputation stack (missRanger, mice, ranger) supports the Random Forest and chained imputation procedures described below. The missingness diagnostic stack (naniar, glue) supports the structural analysis in Section 2.3 (Section 2.3). Libraries are loaded via librarian, which installs missing packages automatically and ensures reproducibility across environments.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Preparation</span>"
    ]
  },
  {
    "objectID": "02-data-prep.html#initial-cleaning-and-standardisation",
    "href": "02-data-prep.html#initial-cleaning-and-standardisation",
    "title": "2  Data Preparation",
    "section": "2.2 Initial Cleaning and Standardisation",
    "text": "2.2 Initial Cleaning and Standardisation\nThe raw dataset undergoes three transformations before any missingness analysis or imputation.\n\n\nShow the code\ndf_clean &lt;- df %&gt;%\n  mutate(\n    date = as.Date(date),\n    month = as.factor(month(date)),\n    day = as.factor(wday(date, label = TRUE))\n  ) %&gt;%\n  filter(!is.na(rainfall))\n\ndf_clean %&gt;%\n  head() %&gt;%\n  kable(caption = \"Head of Cleaned Dataset\") %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"))\n\n\n\nHead of Cleaned Dataset\n\n\ndate\nlocation\nmin_temp\nmax_temp\nrainfall\nevaporation\nsunshine\nwind_gust_dir\nwind_gust_speed\nwind_dir9am\nwind_dir3pm\nwind_speed9am\nwind_speed3pm\nhumidity9am\nhumidity3pm\npressure9am\npressure3pm\ncloud9am\ncloud3pm\ntemp9am\ntemp3pm\nrain_today\nrain_tomorrow\nmonth\nday\n\n\n\n\n2008-12-01\nAlbury\n13.4\n22.9\n0.6\nNA\nNA\nW\n44\nW\nWNW\n20\n24\n71\n22\n1007.7\n1007.1\n8\nNA\n16.9\n21.8\nNo\nNo\n12\nMon\n\n\n2008-12-02\nAlbury\n7.4\n25.1\n0.0\nNA\nNA\nWNW\n44\nNNW\nWSW\n4\n22\n44\n25\n1010.6\n1007.8\nNA\nNA\n17.2\n24.3\nNo\nNo\n12\nTue\n\n\n2008-12-03\nAlbury\n12.9\n25.7\n0.0\nNA\nNA\nWSW\n46\nW\nWSW\n19\n26\n38\n30\n1007.6\n1008.7\nNA\n2\n21.0\n23.2\nNo\nNo\n12\nWed\n\n\n2008-12-04\nAlbury\n9.2\n28.0\n0.0\nNA\nNA\nNE\n24\nSE\nE\n11\n9\n45\n16\n1017.6\n1012.8\nNA\nNA\n18.1\n26.5\nNo\nNo\n12\nThu\n\n\n2008-12-05\nAlbury\n17.5\n32.3\n1.0\nNA\nNA\nW\n41\nENE\nNW\n7\n20\n82\n33\n1010.8\n1006.0\n7\n8\n17.8\n29.7\nNo\nNo\n12\nFri\n\n\n2008-12-06\nAlbury\n14.6\n29.7\n0.2\nNA\nNA\nWNW\n56\nW\nW\n19\n24\n55\n23\n1009.2\n1005.4\nNA\nNA\n20.6\n28.9\nNo\nNo\n12\nSat\n\n\n\n\n\nShow the code\ndf_clean %&gt;%\n  tail() %&gt;%\n  kable(caption = \"Tail of Cleaned Dataset\") %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"))\n\n\n\nTail of Cleaned Dataset\n\n\ndate\nlocation\nmin_temp\nmax_temp\nrainfall\nevaporation\nsunshine\nwind_gust_dir\nwind_gust_speed\nwind_dir9am\nwind_dir3pm\nwind_speed9am\nwind_speed3pm\nhumidity9am\nhumidity3pm\npressure9am\npressure3pm\ncloud9am\ncloud3pm\ntemp9am\ntemp3pm\nrain_today\nrain_tomorrow\nmonth\nday\n\n\n\n\n2017-06-20\nUluru\n3.5\n21.8\n0\nNA\nNA\nE\n31\nESE\nE\n15\n13\n59\n27\n1024.7\n1021.2\nNA\nNA\n9.4\n20.9\nNo\nNo\n6\nTue\n\n\n2017-06-21\nUluru\n2.8\n23.4\n0\nNA\nNA\nE\n31\nSE\nENE\n13\n11\n51\n24\n1024.6\n1020.3\nNA\nNA\n10.1\n22.4\nNo\nNo\n6\nWed\n\n\n2017-06-22\nUluru\n3.6\n25.3\n0\nNA\nNA\nNNW\n22\nSE\nN\n13\n9\n56\n21\n1023.5\n1019.1\nNA\nNA\n10.9\n24.5\nNo\nNo\n6\nThu\n\n\n2017-06-23\nUluru\n5.4\n26.9\n0\nNA\nNA\nN\n37\nSE\nWNW\n9\n9\n53\n24\n1021.0\n1016.8\nNA\nNA\n12.5\n26.1\nNo\nNo\n6\nFri\n\n\n2017-06-24\nUluru\n7.8\n27.0\n0\nNA\nNA\nSE\n28\nSSE\nN\n13\n7\n51\n24\n1019.4\n1016.5\n3\n2\n15.1\n26.0\nNo\nNo\n6\nSat\n\n\n2017-06-25\nUluru\n14.9\nNA\n0\nNA\nNA\nNA\nNA\nESE\nESE\n17\n17\n62\n36\n1020.2\n1017.9\n8\n8\n15.0\n20.9\nNo\nNA\n6\nSun\n\n\n\n\n\nColumn standardisation. All variable names are converted to snake_case via janitor::clean_names(), called at ingestion. This eliminates downstream ambiguity in variable references and ensures internal consistency across all chapters.\nTemporal feature extraction. The date column is typed as a Date object and two derived features are extracted: month (as a factor) and day (day of week, labelled). Month captures the seasonal structure of Australian precipitation; day of week is retained as a potential control variable for reporting artefacts in the raw data.\nTarget filtering. Observations where rainfall is missing are removed. Records without a ground-truth rainfall measurement have no supervised learning value and cannot contribute to either the hurdle or the intensity component of the ZIG model.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Preparation</span>"
    ]
  },
  {
    "objectID": "02-data-prep.html#sec-missingness-diagnostics",
    "href": "02-data-prep.html#sec-missingness-diagnostics",
    "title": "2  Data Preparation",
    "section": "2.3 Missingness Diagnostics",
    "text": "2.3 Missingness Diagnostics\nBefore designing an imputation strategy, it is necessary to understand the mechanism and structure of the missing data. The choice between imputation methods depends critically on three questions: whether missingness is random with respect to other variables in the dataset, whether missing values cluster at specific locations or time periods, and whether the four most-affected variables fail independently or as a coordinated group. A strategy designed without answering these questions risks either under-imputing (discarding recoverable signal) or over-imputing (fabricating data in regions where recovery is not possible). The five analyses below provide the empirical basis for each design decision in the pipeline that follows.\n\n2.3.1 Co-missingness Structure\n\n\nShow the code\nhigh_miss_cols &lt;- c(\"sunshine\", \"evaporation\", \"cloud3pm\", \"cloud9am\")\nhigh_miss &lt;- high_miss_cols[high_miss_cols %in% names(df)]\n\ncat(\"High missingness variables:\", paste(high_miss, collapse = \", \"), \"\\n\\n\")\n\n\n#&gt; High missingness variables: sunshine, evaporation, cloud3pm, cloud9am\n\n\nShow the code\nmiss_mat &lt;- df %&gt;%\n  select(all_of(high_miss)) %&gt;%\n  mutate(across(everything(), is.na)) %&gt;%\n  as.matrix() %&gt;%\n  apply(2, as.integer)\n\nintersection_matrix &lt;- crossprod(miss_mat)\ntotal_miss_counts &lt;- diag(intersection_matrix)\n\npct_matrix &lt;- intersection_matrix / total_miss_counts * 100\n\nco_missing_stats &lt;- as.data.frame(as.table(pct_matrix)) %&gt;%\n  rename(var1 = Var1, var2 = Var2, pct_co_miss = Freq) %&gt;%\n  filter(var1 != var2) %&gt;%\n  arrange(desc(pct_co_miss))\n\nco_missing_stats %&gt;%\n  mutate(\n    msg = glue(\n      \"  {var1} -&gt; {var2}: {round(pct_co_miss, 1)}%  (when {var1} is missing, {var2} is missing)\"\n    )\n  ) %&gt;%\n  pull(msg) %&gt;%\n  walk(cat, \"\\n\")\n\n\n#&gt;   evaporation -&gt; sunshine: 93.2%  (when evaporation is missing, sunshine is missing) \n#&gt;   cloud9am -&gt; cloud3pm: 92.6%  (when cloud9am is missing, cloud3pm is missing) \n#&gt;   cloud3pm -&gt; cloud9am: 87.2%  (when cloud3pm is missing, cloud9am is missing) \n#&gt;   cloud9am -&gt; sunshine: 84.3%  (when cloud9am is missing, sunshine is missing) \n#&gt;   sunshine -&gt; evaporation: 83.8%  (when sunshine is missing, evaporation is missing) \n#&gt;   cloud3pm -&gt; sunshine: 82.5%  (when cloud3pm is missing, sunshine is missing) \n#&gt;   cloud9am -&gt; evaporation: 81.4%  (when cloud9am is missing, evaporation is missing) \n#&gt;   cloud3pm -&gt; evaporation: 78%  (when cloud3pm is missing, evaporation is missing) \n#&gt;   evaporation -&gt; cloud3pm: 73.7%  (when evaporation is missing, cloud3pm is missing) \n#&gt;   evaporation -&gt; cloud9am: 72.5%  (when evaporation is missing, cloud9am is missing) \n#&gt;   sunshine -&gt; cloud3pm: 70.1%  (when sunshine is missing, cloud3pm is missing) \n#&gt;   sunshine -&gt; cloud9am: 67.5%  (when sunshine is missing, cloud9am is missing)\n\n\nShow the code\nco_missing_stats %&gt;%\n  kable(\n    caption = \"Conditional Co-missingness: when var1 is missing, what percentage of the time is var2 also missing?\",\n    digits = 1,\n    col.names = c(\"Variable 1 (Missing)\", \"Variable 2\", \"Co-missing (%)\")\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\n\nTable 2.1: Conditional Co-missingness Matrix\n\n\n\n\nConditional Co-missingness: when var1 is missing, what percentage of the time is var2 also missing?\n\n\nVariable 1 (Missing)\nVariable 2\nCo-missing (%)\n\n\n\n\nevaporation\nsunshine\n93.2\n\n\ncloud9am\ncloud3pm\n92.6\n\n\ncloud3pm\ncloud9am\n87.2\n\n\ncloud9am\nsunshine\n84.3\n\n\nsunshine\nevaporation\n83.8\n\n\ncloud3pm\nsunshine\n82.5\n\n\ncloud9am\nevaporation\n81.4\n\n\ncloud3pm\nevaporation\n78.0\n\n\nevaporation\ncloud3pm\n73.7\n\n\nevaporation\ncloud9am\n72.5\n\n\nsunshine\ncloud3pm\n70.1\n\n\nsunshine\ncloud9am\n67.5\n\n\n\n\n\n\n\n\nThe co-missingness matrix (Table 2.1) confirms that these four variables fail as a systematic cluster rather than independently. The dependencies are strongest between instrumental pairs: if evaporation is missing, there is a 93.2% probability that sunshine is also missing. Even the weakest relationship in the matrix (sunshine to cloud9am) retains a rate of 67.5%, which is nearly double what would be expected under random failure.\nUnder MCAR, the co-missing rates would be close to the marginal missingness rates of each variable, roughly 40 to 48%. Rates uniformly between 67% and 93% instead indicate a shared upstream cause: the instrumentation profile of each station. Sunshine recorders, evaporation pans, and cloud coverage sensors are deployed as a package, not individually. A station without one is very likely to lack the others. This is MNAR at the station level. The practical consequence for imputation is that treating the four variables as independently missing would be incorrect: their correlations when observed are available precisely because they fail together, and a multivariate imputation method that exploits those cross-variable relationships will outperform four separate univariate models.\n\n\n2.3.2 Temporal Structure and Structural Breaks\n\n\nShow the code\ntemporal_trend &lt;- df %&gt;%\n  mutate(month_floor = floor_date(date, \"month\")) %&gt;%\n  select(month_floor, any_of(high_miss)) %&gt;%\n  pivot_longer(\n    cols = -month_floor,\n    names_to = \"variable\",\n    values_to = \"value\"\n  ) %&gt;%\n  group_by(month_floor, variable) %&gt;%\n  summarise(pct_missing = mean(is.na(value)) * 100, .groups = \"drop\")\n\nggplot(\n  temporal_trend,\n  aes(x = month_floor, y = pct_missing, color = variable)\n) +\n  geom_line(linewidth = 1) +\n  facet_wrap(~variable, scales = \"free_y\", ncol = 1) +\n  labs(\n    title = \"Timeline of Systematic Missingness\",\n    subtitle = \"Structural breaks appear as step changes rather than random fluctuations\",\n    y = \"Missingness (%)\",\n    x = \"Year\"\n  ) +\n  theme_minimal() +\n  scale_y_continuous(limits = c(0, 100))\n\n\n\n\n\n\n\n\nFigure 2.1: Timeline of systematic missingness across the four high-missingness variables. The stepped increases visible particularly in sunshine and evaporation indicate structural breaks in data collection rather than random sensor failures.\n\n\n\n\n\nThe temporal analysis (Figure 2.1) confirms that missingness is not randomly distributed over time. The cloud cover variables maintain a roughly stable and high missingness rate across the observation window, consistent with a fixed set of stations never having recorded these measurements. The sunshine and evaporation variables show a distinct stepped pattern: missingness rises at specific breakpoints rather than fluctuating randomly, indicating that certain stations were decommissioned or that recording protocols changed at identifiable calendar dates.\nThis temporal structure has a direct implication for the interpolation stage of the pipeline. Linear interpolation is appropriate when a smooth trajectory can be inferred from values on either side of a gap. Extended contiguous gaps produced by a structural break have no valid upper boundary from which to interpolate, and filling them with temporal interpolation would create long synthetic sequences with no empirical anchor. The five-day interpolation cap set in Stage 1 of the pipeline is a direct response to this finding.\n\n\n2.3.3 Geographic Concentration: Ghost Sensor Identification\n\n\nShow the code\nGHOST_THRESHOLD &lt;- 0.90\n\nlocation_summary &lt;- df %&gt;%\n  group_by(location) %&gt;%\n  naniar::miss_var_summary()\n\nghost_sensors &lt;- location_summary %&gt;%\n  filter(variable %in% high_miss, pct_miss &gt; GHOST_THRESHOLD * 100) %&gt;%\n  arrange(desc(pct_miss))\n\nghost_sensors %&gt;%\n  kable(\n    caption = \"Ghost Sensor Instances: Location-Variable Pairs with &gt;90% Missingness\",\n    digits = 1,\n    col.names = c(\"Location\", \"Variable\", \"Missing (n)\", \"Missing (%)\")\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nGhost Sensor Instances: Location-Variable Pairs with &gt;90% Missingness\n\n\nLocation\nVariable\nMissing (n)\nMissing (%)\n\n\n\n\nAlbury\nevaporation\n3040\n100\n\n\nAlbury\nsunshine\n3040\n100\n\n\nBadgerysCreek\nevaporation\n3009\n100\n\n\nBadgerysCreek\nsunshine\n3009\n100\n\n\nBadgerysCreek\ncloud9am\n3009\n100\n\n\nBadgerysCreek\ncloud3pm\n3009\n100\n\n\nNewcastle\nevaporation\n3039\n100\n\n\nNewcastle\nsunshine\n3039\n100\n\n\nNorahHead\nevaporation\n3004\n100\n\n\nNorahHead\nsunshine\n3004\n100\n\n\nNorahHead\ncloud9am\n3004\n100\n\n\nNorahHead\ncloud3pm\n3004\n100\n\n\nPenrith\nevaporation\n3039\n100\n\n\nPenrith\nsunshine\n3039\n100\n\n\nPenrith\ncloud9am\n3039\n100\n\n\nPenrith\ncloud3pm\n3039\n100\n\n\nRichmond\nsunshine\n3009\n100\n\n\nWollongong\nevaporation\n3040\n100\n\n\nWollongong\nsunshine\n3040\n100\n\n\nTuggeranong\nevaporation\n3039\n100\n\n\nTuggeranong\nsunshine\n3039\n100\n\n\nTuggeranong\ncloud9am\n3039\n100\n\n\nTuggeranong\ncloud3pm\n3039\n100\n\n\nMountGinini\nevaporation\n3040\n100\n\n\nMountGinini\nsunshine\n3040\n100\n\n\nMountGinini\ncloud9am\n3040\n100\n\n\nMountGinini\ncloud3pm\n3040\n100\n\n\nBallarat\nevaporation\n3040\n100\n\n\nBallarat\nsunshine\n3040\n100\n\n\nBendigo\nsunshine\n3040\n100\n\n\nNhil\nevaporation\n1578\n100\n\n\nNhil\nsunshine\n1578\n100\n\n\nNhil\ncloud9am\n1578\n100\n\n\nNhil\ncloud3pm\n1578\n100\n\n\nDartmoor\ncloud9am\n3009\n100\n\n\nDartmoor\ncloud3pm\n3009\n100\n\n\nGoldCoast\nevaporation\n3040\n100\n\n\nGoldCoast\nsunshine\n3040\n100\n\n\nGoldCoast\ncloud9am\n3040\n100\n\n\nGoldCoast\ncloud3pm\n3040\n100\n\n\nAdelaide\ncloud9am\n3193\n100\n\n\nAdelaide\ncloud3pm\n3193\n100\n\n\nWitchcliffe\nevaporation\n3009\n100\n\n\nWitchcliffe\nsunshine\n3009\n100\n\n\nWitchcliffe\ncloud9am\n3009\n100\n\n\nWitchcliffe\ncloud3pm\n3009\n100\n\n\nPearceRAAF\nevaporation\n3009\n100\n\n\nSalmonGums\nevaporation\n3001\n100\n\n\nSalmonGums\nsunshine\n3001\n100\n\n\nSalmonGums\ncloud9am\n3001\n100\n\n\nSalmonGums\ncloud3pm\n3001\n100\n\n\nWalpole\nevaporation\n3006\n100\n\n\nWalpole\nsunshine\n3006\n100\n\n\nWalpole\ncloud9am\n3006\n100\n\n\nWalpole\ncloud3pm\n3006\n100\n\n\nLaunceston\nsunshine\n3040\n100\n\n\nKatherine\nsunshine\n1578\n100\n\n\nUluru\nevaporation\n1578\n100\n\n\nUluru\nsunshine\n1578\n100\n\n\nLaunceston\nevaporation\n2899\n95.4\n\n\n\n\n\nShow the code\ncat(sprintf(\n  \"\\nTotal ghost sensor instances identified: %d across %d locations\\n\",\n  nrow(ghost_sensors),\n  n_distinct(ghost_sensors$location)\n))\n\n\n#&gt; \n#&gt; Total ghost sensor instances identified: 60 across 22 locations\n\n\nThe location-level analysis identifies the specific station-variable pairs responsible for the bulk of the aggregate missingness. The top ten instances from the script output, all at exactly 100% missing, are as follows: Albury (evaporation, 3,040 observations; sunshine, 3,040), BadgerysCreek (evaporation, 3,009; sunshine, 3,009; cloud9am, 3,009; cloud3pm, 3,009), Newcastle (evaporation, 3,039; sunshine, 3,039), and NorahHead (evaporation, 3,004; sunshine, 3,004). At these stations, the instrument in question recorded a value on zero days across the entire observation window. These are not sensors experiencing intermittent failure; they are sensors that were never present or that were removed before the data collection period began.\nThe distinction between ghost sensors and ordinary missingness is consequential for imputation. For a gap of five to fifteen consecutive missing days, a Random Forest model can generate reasonable predictions by drawing on correlated variables at the same station and the same variable at nearby stations. For a gap spanning 3,000 or more consecutive observations, this extrapolation has no empirical support whatsoever: there is no observed value at that station and variable combination to anchor or validate the prediction. Values produced for these pairs would be statistically plausible by construction but would carry no physical information about what the instrument would have actually recorded. Ghost sensor pairs are identified before Stage 2 runs and flagged so that their imputed values can be treated with appropriate scepticism in downstream analysis.\n\n\n2.3.4 Weather-Conditionality of Sunshine Missingness\n\n\nShow the code\nif (all(c(\"rainfall\", \"sunshine\") %in% names(df))) {\n  weather_missing_stats &lt;- df %&gt;%\n    filter(!is.na(rainfall)) %&gt;%\n    mutate(is_rainy = if_else(rainfall &gt; 1, \"Rainy (&gt;1mm)\", \"Dry (&lt;=1mm)\")) %&gt;%\n    group_by(is_rainy) %&gt;%\n    summarise(\n      n_obs = n(),\n      pct_sunshine_missing = mean(is.na(sunshine)) * 100,\n      .groups = \"drop\"\n    )\n\n  print(weather_missing_stats)\n\n  weather_missing_stats %&gt;%\n    kable(\n      caption = \"Sunshine Missingness Rate by Daily Rainfall Status\",\n      digits = 1,\n      col.names = c(\"Day Type\", \"Observations (n)\", \"Sunshine Missing (%)\")\n    ) %&gt;%\n    kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n}\n\n\n#&gt; # A tibble: 2 × 3\n#&gt;   is_rainy      n_obs pct_sunshine_missing\n#&gt;   &lt;chr&gt;         &lt;int&gt;                &lt;dbl&gt;\n#&gt; 1 Dry (&lt;=1mm)  110319                 47.8\n#&gt; 2 Rainy (&gt;1mm)  31880                 47.2\n\n\n\n\nTable 2.2: Sunshine Missingness Rate by Daily Rainfall Status\n\n\n\n\n\n\nDay Type\nObservations (n)\nSunshine Missing (%)\n\n\n\n\nDry (&lt;=1mm)\n110319\n47.8\n\n\nRainy (&gt;1mm)\n31880\n47.2\n\n\n\n\n\n\n\n\n\n\nShow the code\ndf %&gt;%\n  naniar::bind_shadow() %&gt;%\n  filter(rainfall &gt; 0 & rainfall &lt; 50) %&gt;%\n  ggplot(aes(x = rainfall, fill = sunshine_NA)) +\n  geom_density(alpha = 0.6) +\n  scale_fill_viridis_d(labels = c(\"!NA\" = \"Present\", \"NA\" = \"Missing\")) +\n  labs(\n    title = \"Does Sunshine go Missing on Rainy Days?\",\n    subtitle = \"Density of rainfall amounts for days with Missing vs. Present sunshine data\",\n    x = \"Rainfall (mm)\",\n    y = \"Density\",\n    fill = \"Sunshine Status\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nFigure 2.2: Density of rainfall amounts on days where sunshine data is present versus missing. The near-identical distributions confirm that sunshine missingness is not weather-conditional: the same stations are missing sunshine on both dry and rainy days because the instrument was simply not installed, not because it failed during precipitation events.\n\n\n\n\n\nA specific concern when imputing a predictor variable is outcome-related missingness: if sunshine sensors failed more often on rainy days, then the imputed values would carry a directional signal about the target variable and could introduce bias into the training data.\nThe empirical test refutes this concern. The table output (Table 2.2) reports a sunshine missing rate of 47.8% on 110,319 dry days (rainfall at most 1 mm) and 47.2% on 31,880 rainy days (rainfall above 1 mm), a difference of 0.6 percentage points. The density plot (Figure 2.2) makes the same point visually: the distribution of rainfall amounts on days with missing sunshine and on days with present sunshine are indistinguishable across the full range from 0 to 50 mm. The slight visual offset in the figure reflects not a systematic pattern but the difference in the sizes of the two groups.\nSunshine missingness is station-conditional rather than weather-conditional. The same stations record missing sunshine on both dry and rainy days at nearly identical rates, because the instrument is absent from those stations entirely. This finding clears the imputation path: there is no outcome-related confound to correct for.\n\n\n2.3.5 Missing Pattern Structure\n\n\nShow the code\ncat(\"Missing pattern combinations:\\n\")\n\n\n#&gt; Missing pattern combinations:\n\n\nShow the code\ndf %&gt;%\n  select(all_of(high_miss)) %&gt;%\n  naniar::miss_case_table() %&gt;%\n  print()\n\n\n#&gt; # A tibble: 5 × 3\n#&gt;   n_miss_in_case n_cases pct_cases\n#&gt;            &lt;int&gt;   &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1              0   62566     43.0 \n#&gt; 2              1   10525      7.24\n#&gt; 3              2   20376     14.0 \n#&gt; 4              3   11378      7.82\n#&gt; 5              4   40615     27.9\n\n\nShow the code\ndf %&gt;%\n  select(all_of(high_miss)) %&gt;%\n  naniar::miss_case_table() %&gt;%\n  kable(\n    caption = \"Distribution of Missing Variable Count per Observation\",\n    col.names = c(\n      \"Variables Missing (of 4)\",\n      \"Observations (n)\",\n      \"Percentage (%)\"\n    )\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nDistribution of Missing Variable Count per Observation\n\n\nVariables Missing (of 4)\nObservations (n)\nPercentage (%)\n\n\n\n\n0\n62566\n43.012512\n\n\n1\n10525\n7.235666\n\n\n2\n20376\n14.007975\n\n\n3\n11378\n7.822082\n\n\n4\n40615\n27.921765\n\n\n\n\n\nThe case-level output from the script reveals a strongly bimodal structure across five distinct patterns. Of all observations: 62,566 (43.0%) have none of the four variables missing; 10,525 (7.2%) have exactly one missing; 20,376 (14.0%) have exactly two missing; 11,378 (7.8%) have exactly three missing; and 40,615 (27.9%) have all four missing simultaneously. The two endpoint categories, zero missing and all four missing, together account for 70.9% of all observations.\nThe 27.9% with complete simultaneous missingness corresponds directly to the ghost sensor stations identified in Section 2.3.3. For these observations, no imputation is supportable and the values remain missing after the pipeline. The 43.0% with no missingness require no intervention. The substantive imputation work is concentrated in the remaining 29.1% across the three intermediate patterns, where partial instrumentation means that correlated predictors are available to inform the Random Forest estimates. The bimodal structure also confirms that the co-missingness finding is not a statistical artifact: observations genuinely tend to be fully instrumented or minimally instrumented, not randomly partially instrumented.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Preparation</span>"
    ]
  },
  {
    "objectID": "02-data-prep.html#imputation-pipeline",
    "href": "02-data-prep.html#imputation-pipeline",
    "title": "2  Data Preparation",
    "section": "2.4 Imputation Pipeline",
    "text": "2.4 Imputation Pipeline\nThe diagnostic evidence from Section 2.3 motivates each design decision in the imputation pipeline. Missingness is station-level rather than weather-conditional (Section 2.3.4), temporally structured with extended contiguous gaps rather than random scatter (Section 2.3.2), and co-located across variables at the station level (Section 2.3.1). These properties rule out simple listwise deletion and mean imputation. They call for a pipeline that respects temporal continuity for smoothly-evolving variables, exploits cross-variable correlations for the structured variables, and declines to impute where the data is genuinely unrecoverable.\n\n2.4.1 Stage 1: Temporal Interpolation\nThe eight variables with smooth day-to-day trajectories minimum and maximum temperature, morning and afternoon temperature, morning and afternoon pressure, and morning and afternoon humidity are imputed via linear interpolation grouped by location, bounded by a five-day maximum gap. The five-day cap is set directly in response to the temporal structural break finding: gaps of up to five days lie within a regime where the values at both boundaries sufficiently constrain the trajectory, while longer gaps are associated with structural collection failures that interpolation cannot safely bridge.\n\n\n2.4.2 Stage 2: Multivariate Random Forest Imputation\nRemaining gaps in sunshine, evaporation, cloud cover, and wind direction are addressed using mice with a Random Forest method. Each variable is imputed from a scientifically motivated predictor set:\n\nCloud cover (cloud9am, cloud3pm) from humidity and pressure.\nSunshine from cloud cover, temperature, humidity, location, and month.\nEvaporation from wind gust speed, temperature, humidity, sunshine, location, and month.\nWind direction (wind_gust_dir, wind_dir9am, wind_dir3pm) from the corresponding wind speed, pressure, location, and month.\n\nWind direction is treated as a categorical variable imputed with Random Forest, which handles the multi-class, non-ordinal nature of compass-point directions without imposing a false numeric ordering. Each wind direction variable uses its temporally matched pressure and speed readings as predictors gust direction from gust speed and 3pm pressure, 9am direction from 9am speed and pressure, and 3pm direction from 3pm speed and pressure preserving the physical coupling between concurrent measurements.\nThe use of targeted predictor sets is directly motivated by the co-missingness finding. Because the four atmosphere variables tend to be absent together at the station level, their cross-variable correlations when observed are strong and reliable signals for imputation. Restricting each variable’s predictor set to physically motivated covariates exploits this structure while reducing the risk of imputing on spurious correlations.\n\n\n2.4.3 Ghost Sensor Flagging\nBefore Stage 2 runs, all station-variable pairs identified in Section 2.3.3 as ghost sensors (more than 90% missing across the full observation window) are catalogued and binary missingness flags are attached to the data (sunshine_imp_flagged, evap_imp_flagged, cloud3pm_imp_flagged, cloud9am_imp_flagged). These flags serve two purposes: they are excluded from the MICE predictor matrix so they cannot contaminate the imputation model, and they remain in the final dataset as explicit markers of which values are extrapolated with no empirical anchor. Flag columns are also excluded from the predictor matrix alongside the raw date column to prevent data leakage. A Random Forest model has no empirical support for predicting values at a station where an instrument was never present; the flags make this provenance transparent for any downstream analysis that needs to account for it.\n\n\nShow the code\nclean_and_impute_weather &lt;- function(df) {\n  MAXGAP &lt;- 5\n  GHOST_THRESHOLD &lt;- 0.90\n  M &lt;- 5\n\n  df &lt;- df %&gt;%\n    clean_names() %&gt;%\n    mutate(\n      date = as.Date(date),\n      month = as.factor(month(date)),\n      day = as.factor(wday(date, label = TRUE)),\n      day_of_year = yday(date),\n      wind_gust_dir = as.factor(wind_gust_dir),\n      wind_dir9am = as.factor(wind_dir9am),\n      wind_dir3pm = as.factor(wind_dir3pm),\n      rain_today = as.factor(rain_today),\n      location = as.factor(location)\n    ) %&gt;%\n    filter(!is.na(rainfall)) %&gt;%\n    select(-rain_tomorrow)\n\n  # Interpolation\n  interp_vars &lt;- c(\n    \"min_temp\",\n    \"max_temp\",\n    \"temp9am\",\n    \"temp3pm\",\n    \"pressure9am\",\n    \"pressure3pm\",\n    \"humidity9am\",\n    \"humidity3pm\"\n  )\n\n  df_interp &lt;- df %&gt;%\n    group_by(location) %&gt;%\n    arrange(date, .by_group = TRUE) %&gt;%\n    mutate(across(\n      all_of(interp_vars),\n      ~ na.approx(., maxgap = MAXGAP, na.rm = FALSE, rule = 2)\n    )) %&gt;%\n    ungroup()\n\n  # Flag ghost vars\n  ghost_prone_vars &lt;- c(\"sunshine\", \"evaporation\", \"cloud3pm\", \"cloud9am\")\n\n  ghost_pairs &lt;- df_interp %&gt;%\n    select(location, all_of(ghost_prone_vars)) %&gt;%\n    pivot_longer(\n      cols = all_of(ghost_prone_vars),\n      names_to = \"variable\",\n      values_to = \"value\"\n    ) %&gt;%\n    group_by(location, variable) %&gt;%\n    summarise(miss_rate = mean(is.na(value)) * 100, .groups = \"drop\") %&gt;%\n    filter(miss_rate &gt; (GHOST_THRESHOLD * 100))\n\n  cat(sprintf(\"  Found %d ghost sensor instances\\n\", nrow(ghost_pairs)))\n\n  df_flagged &lt;- df_interp %&gt;%\n    mutate(\n      sunshine_imp_flagged = as.integer(is.na(sunshine)),\n      evap_imp_flagged = as.integer(is.na(evaporation)),\n      cloud3pm_imp_flagged = as.integer(is.na(cloud3pm)),\n      cloud9am_imp_flagged = as.integer(is.na(cloud9am))\n    )\n\n  # MICE setup\n  wind_vars &lt;- c(\"wind_gust_dir\", \"wind_dir9am\", \"wind_dir3pm\")\n\n  init &lt;- mice(df_flagged, maxit = 0)\n  pred &lt;- init$predictorMatrix\n  meth &lt;- init$method\n\n  pred[,] &lt;- 0\n\n  meth[ghost_prone_vars] &lt;- \"rf\"\n  meth[wind_vars] &lt;- \"rf\"\n\n  sun_predictors &lt;- intersect(\n    colnames(df_flagged),\n    c(\"cloud9am\", \"cloud3pm\", \"max_temp\", \"humidity3pm\", \"location\", \"month\")\n  )\n  evap_predictors &lt;- intersect(\n    colnames(df_flagged),\n    c(\n      \"wind_gust_speed\",\n      \"max_temp\",\n      \"humidity3pm\",\n      \"sunshine\",\n      \"location\",\n      \"month\"\n    )\n  )\n  cloud_predictors &lt;- intersect(\n    colnames(df_flagged),\n    c(\"humidity9am\", \"humidity3pm\", \"pressure9am\", \"location\", \"month\")\n  )\n  wind_gust_predictors &lt;- intersect(\n    colnames(df_flagged),\n    c(\"wind_gust_speed\", \"pressure3pm\", \"location\", \"month\")\n  )\n  wind_9am_predictors &lt;- intersect(\n    colnames(df_flagged),\n    c(\"wind_speed9am\", \"pressure9am\", \"location\", \"month\")\n  )\n  wind_3pm_predictors &lt;- intersect(\n    colnames(df_flagged),\n    c(\"wind_speed3pm\", \"pressure3pm\", \"location\", \"month\")\n  )\n\n  if (\"sunshine\" %in% rownames(pred)) {\n    pred[\"sunshine\", sun_predictors] &lt;- 1\n  }\n  if (\"evaporation\" %in% rownames(pred)) {\n    pred[\"evaporation\", evap_predictors] &lt;- 1\n  }\n  if (\"cloud9am\" %in% rownames(pred)) {\n    pred[\"cloud9am\", cloud_predictors] &lt;- 1\n  }\n  if (\"cloud3pm\" %in% rownames(pred)) {\n    pred[\"cloud3pm\", cloud_predictors] &lt;- 1\n  }\n  if (\"wind_gust_dir\" %in% rownames(pred)) {\n    pred[\"wind_gust_dir\", wind_gust_predictors] &lt;- 1\n  }\n  if (\"wind_dir9am\" %in% rownames(pred)) {\n    pred[\"wind_dir9am\", wind_9am_predictors] &lt;- 1\n  }\n  if (\"wind_dir3pm\" %in% rownames(pred)) {\n    pred[\"wind_dir3pm\", wind_3pm_predictors] &lt;- 1\n  }\n\n  ignore_cols &lt;- grep(\"_imp_flagged$|^date$\", colnames(pred), value = TRUE)\n  pred[, ignore_cols] &lt;- 0\n\n  # Parallel imputation with exact m allocation across cores\n  n_cores &lt;- max(1L, min(as.integer(parallel::detectCores()), as.integer(M)))\n  m_split &lt;- rep(M %/% n_cores, n_cores)\n  if ((M %% n_cores) &gt; 0L) {\n    m_split[seq_len(M %% n_cores)] &lt;- m_split[seq_len(M %% n_cores)] + 1L\n  }\n\n  seeds &lt;- 123 + seq_len(n_cores) - 1L\n\n  imp_list &lt;- parallel::mclapply(\n    seq_len(n_cores),\n    function(i) {\n      mice(\n        df_flagged,\n        method = meth,\n        predictorMatrix = pred,\n        m = m_split[i],\n        maxit = 5,\n        seed = seeds[i],\n        printFlag = FALSE\n      )\n    },\n    mc.cores = n_cores\n  )\n\n  # Merge all mids objects into one for MI inference\n  imp_merged &lt;- Reduce(ibind, imp_list)\n  return(imp_merged)\n}\n\n\n\n\nShow the code\nimp_mids &lt;- clean_and_impute_weather(df)\ndf_final &lt;- complete(imp_mids, action = 1)\nwrite_csv(df_final, \"data/df_final.csv\")",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Preparation</span>"
    ]
  },
  {
    "objectID": "02-data-prep.html#post-imputation-dataset-properties",
    "href": "02-data-prep.html#post-imputation-dataset-properties",
    "title": "2  Data Preparation",
    "section": "2.5 Post-Imputation Dataset Properties",
    "text": "2.5 Post-Imputation Dataset Properties\nThe two-stage pipeline produces a dataset whose properties are each traceable to a specific finding from the diagnostic analysis.\nRetention without fabrication. No observations are discarded on the basis of partial missingness. The 27.9% of observations with all four target variables simultaneously absent are retained with those variables still missing, consistent with the ghost sensor finding that no empirically supportable imputation is possible for them.\nTemporal coherence. The interpolated variables maintain their within-location autocorrelation structure. The five-day cap, set in response to the temporal structural break analysis, prevents the interpolation from extending across genuine data voids.\nDistributional fidelity. The Random Forest method within MICE draws imputed values from the observed empirical distribution of each variable, preserving marginal distributions and preventing variance shrinkage.\nOutcome independence. The weather-conditionality test confirmed that sunshine missingness does not covary with rainfall amounts. Imputed sunshine values therefore do not introduce a directional bias into the training labels.\nWind direction coherence. Wind direction variables are imputed as categorical factors using Random Forest, with each direction variable conditioned on its temporally matched speed and pressure readings. This preserves the physical coupling between concurrent wind speed and direction measurements while respecting the non-ordinal structure of compass-point categories.\nProvenance transparency. Binary imputation flags for the four ghost-prone variables are retained in the final dataset. These flags enable downstream models or diagnostics to condition on or exclude observations where imputed values carry no empirical anchor at the station level.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Preparation</span>"
    ]
  },
  {
    "objectID": "03-eda.html",
    "href": "03-eda.html",
    "title": "3  Exploratory Data Analysis",
    "section": "",
    "text": "3.1 Temporal and Meteorological Drivers of Australian Rainfall",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#temporal-and-meteorological-drivers-of-australian-rainfall",
    "href": "03-eda.html#temporal-and-meteorological-drivers-of-australian-rainfall",
    "title": "3  Exploratory Data Analysis",
    "section": "",
    "text": "Chapter Context. This chapter investigates the distributional and structural properties of the daily rainfall data, using findings from the data preparation chapter (Chapter 2) as its starting point rather than repeating the missingness diagnostics performed there. The analyses proceed in a deliberate sequence: target variable distribution, bivariate predictor correlations, temporal dynamics, pressure analysis, seasonal patterns, and feature interactions. Each section produces a specific finding that motivates a corresponding decision in the feature engineering or model specification stages.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#sec-data-quality",
    "href": "03-eda.html#sec-data-quality",
    "title": "3  Exploratory Data Analysis",
    "section": "3.2 Data Quality Summary",
    "text": "3.2 Data Quality Summary\nA thorough investigation of missingness is documented in Chapter 2 and summarised briefly here for continuity. The full diagnostic pipeline co-missingness analysis, temporal structural break detection, ghost sensor identification, and a weather-conditionality test established the following picture.\nThe dataset contains 314,146 missing entries in total, distributed highly unevenly across features. The four most affected variables are sunshine (47.7% missing), evaporation (42.5%), cloud9am (approximately 40%), and cloud3pm (approximately 37%). Their missingness is not independent: co-missing rates between any pair of these four variables range from 67% to 93%, confirming that they fail together at the station level rather than through separate independent sensor faults. This is Missing Not At Random at the station level, driven by instrumentation deployment profiles.\nA weather-conditionality test confirmed that sunshine missingness does not covary with rainfall amounts: the missing rate is 47.8% on dry days and 47.2% on rainy days. Missingness is station-conditional rather than outcome-conditional, meaning imputed values do not introduce directional bias into the training labels.\nThe core dynamic variables pressure, wind speed, temperature, and humidity exhibit missingness below 10% and are available across virtually all observations.\n\n\nShow the code\ntotal_na &lt;- sum(is.na(df_clean))\nprint(paste(\"Total missing values:\", total_na))\n\n\n#&gt; [1] \"Total missing values: 314146\"\n\n\nShow the code\nmissing_val(df_clean)\n\n\n\nPercentage of Missing Values by Feature\n\n\ncolumn\npct_missing\n\n\n\n\nsunshine\n47.6937250\n\n\nevaporation\n42.5375706\n\n\ncloud3pm\n39.9960619\n\n\ncloud9am\n37.5044832\n\n\npressure3pm\n9.8404349\n\n\npressure9am\n9.8031632\n\n\nwind_dir9am\n6.8840147\n\n\nwind_gust_dir\n6.8390073\n\n\nwind_gust_speed\n6.7968129\n\n\nwind_dir3pm\n2.6716081\n\n\nhumidity3pm\n2.5527606\n\n\ntemp3pm\n1.9310966\n\n\nwind_speed3pm\n1.8614758\n\n\nhumidity9am\n1.0928347\n\n\nrain_tomorrow\n0.9929746\n\n\nwind_speed9am\n0.7672347\n\n\ntemp9am\n0.4817193\n\n\nmin_temp\n0.3424778\n\n\nmax_temp\n0.3305227\n\n\ndate\n0.0000000\n\n\nlocation\n0.0000000\n\n\nrainfall\n0.0000000\n\n\nrain_today\n0.0000000\n\n\nmonth\n0.0000000\n\n\nday\n0.0000000\n\n\n\n\n\nResolution. A two-stage hybrid imputation pipeline was applied in Chapter 2: linear temporal interpolation bounded by a five-day cap for the eight smoothly-evolving meteorological variables, followed by multivariate Random Forest imputation via mice for the four atmosphere variables (sunshine, evaporation, cloud9am, cloud3pm) and the three wind direction variables (wind_gust_dir, wind_dir9am, wind_dir3pm). Each variable’s predictor set was restricted to physically motivated covariates: cloud cover from humidity and pressure, sunshine from cloud cover and temperature, evaporation from wind speed, temperature and humidity, and wind direction from the corresponding wind speed, pressure, location, and month. Ghost sensor station-variable pairs, those with more than 90% missingness across the full observation window, were identified before the Random Forest stage and carried forward with binary imputation flags (sunshine_imp_flagged, evap_imp_flagged, cloud3pm_imp_flagged, cloud9am_imp_flagged) rather than populated with extrapolations that have no empirical anchor. The imputed dataset df_final is used throughout the remainder of this chapter. The raw dataset df_clean is used only in this opening section, where using pre-imputation data avoids circularity between the imputed features and the response distribution.\nModelling implication. The concentration of missingness in sunshine and evaporation, both of which exhibit meaningful correlation with rainfall, as shown in Section 3.4, creates a direct trade-off: discarding these variables avoids imputation complexity but sacrifices predictive signal, while listwise deletion would eliminate nearly half the dataset and introduce geographic bias toward well-instrumented stations. The Random Forest imputation strategy in Chapter 2 resolves this trade-off by preserving both sample and features.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#distributional-properties-of-the-target-variable",
    "href": "03-eda.html#distributional-properties-of-the-target-variable",
    "title": "3  Exploratory Data Analysis",
    "section": "3.3 Distributional Properties of the Target Variable",
    "text": "3.3 Distributional Properties of the Target Variable\nUnderstanding the marginal distribution of the response variable is a prerequisite for selecting an appropriate model family. A Gaussian assumption carries substantive claims about the data-generating process that can be directly tested.\n\n\nShow the code\nrainfall_stats &lt;- df_clean %&gt;%\n  summarise(\n    n = n(),\n    mean = mean(rainfall),\n    median = median(rainfall),\n    sd = sd(rainfall),\n    min = min(rainfall),\n    max = max(rainfall),\n    q25 = quantile(rainfall, 0.25),\n    q75 = quantile(rainfall, 0.75),\n    iqr = IQR(rainfall),\n    n_zeros = sum(rainfall == 0),\n    pct_zeros = mean(rainfall == 0) * 100,\n    n_large = sum(rainfall &gt; 100),\n    pct_large = mean(rainfall &gt; 100) * 100,\n    skewness = moments::skewness(rainfall),\n    kurtosis = moments::kurtosis(rainfall)\n  )\n\nrainfall_stats %&gt;%\n  pivot_longer(everything(), names_to = \"Statistic\", values_to = \"Value\") %&gt;%\n  mutate(\n    Value = ifelse(\n      Value &gt; 1000,\n      format(Value, scientific = TRUE, digits = 3),\n      round(Value, 3)\n    )\n  ) %&gt;%\n  kable(\n    caption = \"Descriptive Statistics: Daily Rainfall (mm)\",\n    align = \"lr\"\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nDescriptive Statistics: Daily Rainfall (mm)\n\n\nStatistic\nValue\n\n\n\n\nn\n1.42e+05\n\n\nmean\n2.361\n\n\nmedian\n0\n\n\nsd\n8.478\n\n\nmin\n0\n\n\nmax\n371\n\n\nq25\n0\n\n\nq75\n0.8\n\n\niqr\n0.8\n\n\nn_zeros\n9.11e+04\n\n\npct_zeros\n64.051\n\n\nn_large\n151\n\n\npct_large\n0.106\n\n\nskewness\n9.836\n\n\nkurtosis\n181.146\n\n\n\n\n\nShow the code\nrain_check &lt;- df_clean %&gt;%\n  summarise(\n    total_days = n(),\n    dry_days = sum(rainfall == 0),\n    rainy_days = sum(rainfall &gt; 0),\n    zero_inflation_pct = (dry_days / total_days) * 100\n  )\n\nrain_check %&gt;%\n  kable(\n    caption = \"Prevalence of Zero-Inflation (Dry Days)\",\n    col.names = c(\n      \"Total Days\",\n      \"Dry Days (0mm)\",\n      \"Rainy Days (&gt;0mm)\",\n      \"Zero Inflation (%)\"\n    )\n  ) %&gt;%\n  kable_styling(\n    bootstrap_options = c(\"striped\", \"bordered\"),\n    full_width = FALSE\n  )\n\n\n\nPrevalence of Zero-Inflation (Dry Days)\n\n\nTotal Days\nDry Days (0mm)\nRainy Days (&gt;0mm)\nZero Inflation (%)\n\n\n\n\n142199\n91080\n51119\n64.05108\n\n\n\n\n\nThe descriptive statistics reveal a distribution fundamentally incompatible with Gaussian modelling assumptions.\nZero-inflation. 64.05% of the 142,199 recorded observations are dry days (rainfall = 0 mm). The median is zero. The data-generating mechanism genuinely produces two qualitatively different outcomes, no rain at all versus some positive amount and any model treating the response as a single continuous variable will be forced to place probability mass on negative values and will systematically misestimate the probability of the zero outcome.\nHeavy tails. Among non-zero observations, the distribution is severely right-skewed (skewness = 9.84). The standard deviation (8.48 mm) is nearly four times the mean (2.36 mm). Kurtosis of 181.15 compared to 3 for a normal distribution confirms that extreme events occur far more frequently than a Gaussian model would predict. The maximum recorded value is 371 mm, and 151 events exceed 100 mm.\nModelling implication. The conjunction of zero-inflation and extreme positive skew means a single-component model is insufficient. The data implicitly poses two separate questions: does rain occur (binary classification) and, given that it does, how much falls (positive continuous regression). This motivates the Zero-Inflated Gamma framework adopted in subsequent analysis.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#sec-correlation",
    "href": "03-eda.html#sec-correlation",
    "title": "3  Exploratory Data Analysis",
    "section": "3.4 Bivariate Correlation Structure",
    "text": "3.4 Bivariate Correlation Structure\nBecause rainfall is heavily skewed and the relationships are unlikely to be linear, Spearman rank correlation is used throughout, a non-parametric measure that captures monotonic association without requiring linearity or normality.\n\n\nShow the code\nnumeric_cols &lt;- df_clean %&gt;%\n  select(where(is.numeric)) %&gt;%\n  names()\nnumeric_cols &lt;- numeric_cols[numeric_cols != \"rainfall\"]\n\ncors &lt;- df_clean %&gt;%\n  rstatix::cor_test(\n    vars = \"rainfall\",\n    vars2 = numeric_cols,\n    method = \"spearman\"\n  ) %&gt;%\n  filter(!is.na(cor)) %&gt;%\n  arrange(desc(abs(cor))) %&gt;%\n  dplyr::select(var2, cor, p) %&gt;%\n  mutate(\n    interpretation = case_when(\n      abs(cor) &lt; 0.1 ~ \"Negligible\",\n      abs(cor) &lt; 0.3 ~ \"Small\",\n      abs(cor) &lt; 0.5 ~ \"Moderate\",\n      TRUE ~ \"Large\"\n    )\n  )\n\ncors %&gt;%\n  kable(\n    caption = \"Spearman Correlation with Rainfall (Ranked by Strength)\",\n    col.names = c(\"Predictor\", \"Correlation (r)\", \"P-Value\", \"Strength\")\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nSpearman Correlation with Rainfall (Ranked by Strength)\n\n\nPredictor\nCorrelation (r)\nP-Value\nStrength\n\n\n\n\nhumidity9am\n0.440\n0\nModerate\n\n\nhumidity3pm\n0.440\n0\nModerate\n\n\nsunshine\n-0.400\n0\nModerate\n\n\ncloud9am\n0.370\n0\nModerate\n\n\ncloud3pm\n0.320\n0\nModerate\n\n\nevaporation\n-0.310\n0\nModerate\n\n\ntemp3pm\n-0.310\n0\nModerate\n\n\nmax_temp\n-0.300\n0\nModerate\n\n\npressure9am\n-0.150\n0\nSmall\n\n\ntemp9am\n-0.150\n0\nSmall\n\n\nwind_gust_speed\n0.130\n0\nSmall\n\n\nwind_speed9am\n0.083\n0\nNegligible\n\n\nwind_speed3pm\n0.068\n0\nNegligible\n\n\npressure3pm\n-0.063\n0\nNegligible\n\n\nmin_temp\n0.022\n0\nNegligible\n\n\n\n\n\n\n\nShow the code\ncor_matrix &lt;- df_clean %&gt;%\n  select(where(is.numeric)) %&gt;%\n  cor(use = \"pairwise.complete.obs\", method = \"spearman\")\n\ncor_melt &lt;- cor_matrix %&gt;%\n  as.data.frame() %&gt;%\n  rownames_to_column(var = \"Var1\") %&gt;%\n  pivot_longer(cols = -Var1, names_to = \"Var2\", values_to = \"Correlation\")\n\ncor_melt %&gt;%\n  ggplot(aes(x = Var1, y = Var2, fill = Correlation)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradient2(\n    low = \"#D73027\",\n    mid = \"white\",\n    high = \"#4575B4\",\n    midpoint = 0,\n    limit = c(-1, 1),\n    name = \"Spearman\\nCorrelation\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 45, vjust = 1, size = 10, hjust = 1),\n    axis.text.y = element_text(size = 10),\n    axis.title = element_blank(),\n    panel.grid.major = element_blank(),\n    legend.position = \"right\"\n  ) +\n  geom_text(\n    data = filter(cor_melt, abs(Correlation) &gt; 0.3),\n    aes(label = round(Correlation, 2)),\n    color = \"black\",\n    size = 3\n  ) +\n  labs(\n    title = \"Feature Correlation Matrix\",\n    subtitle = \"Strongest predictors: Humidity (positive) and Sunshine (negative)\"\n  )\n\n\n\n\n\n\n\n\nFigure 3.1: Spearman Correlation Matrix of Meteorological Features. Red indicates negative correlation; blue indicates positive correlation. Coefficients shown for pairs where |r| &gt; 0.3.\n\n\n\n\n\n\n\nShow the code\ncor_humidity &lt;- cor.test(\n  df_clean$rainfall,\n  df_clean$humidity3pm,\n  method = \"spearman\"\n)\ncor_sunshine &lt;- cor.test(\n  df_clean$rainfall,\n  df_clean$sunshine,\n  method = \"spearman\"\n)\n\ncocor_result &lt;- cocor.dep.groups.overlap(\n  r.jk = cor_humidity$estimate,\n  r.jh = cor_sunshine$estimate,\n  r.kh = cor(\n    df_clean$humidity3pm,\n    df_clean$sunshine,\n    use = \"complete.obs\",\n    method = \"spearman\"\n  ),\n  n = nrow(df_clean),\n  alternative = \"two.sided\",\n  test = \"steiger1980\",\n  return.htest = TRUE\n)\n\nprint(cocor_result)\n#&gt; $pearson1898\n#&gt; \n#&gt;  Pearson and Filon's z (1898)\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $hotelling1940\n#&gt; \n#&gt;  Hotelling's t (1940)\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $williams1959\n#&gt; \n#&gt;  Williams' t (1959)\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $hendrickson1970\n#&gt; \n#&gt;  Hendrickson, Stanley, and Hills' (1970) modification of Williams' t\n#&gt;  (1959)\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $olkin1967\n#&gt; \n#&gt;  Olkin's z (1967)\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $dunn1969\n#&gt; \n#&gt;  Dunn and Clark's z (1969)\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $steiger1980\n#&gt; \n#&gt;  Steiger's (1980) modification of Dunn and Clark's z (1969) using\n#&gt;  average correlations\n#&gt; \n#&gt; data:  \n#&gt; z = 188.91, p-value &lt; 2.2e-16\n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $meng1992\n#&gt; \n#&gt;  Meng, Rosenthal, and Rubin's z (1992)\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $hittner2003\n#&gt; \n#&gt;  Hittner, May, and Silver's (2003) modification of Dunn and Clark's z\n#&gt;  (1969) using a backtransformed average Fisher's (1921) Z procedure\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376 \n#&gt; \n#&gt; \n#&gt; $zou2007\n#&gt; \n#&gt;  Zou's (2007) confidence interval\n#&gt; \n#&gt; data:  \n#&gt; \n#&gt; alternative hypothesis: true difference in correlations is not equal to 0\n#&gt; sample estimates:\n#&gt;   r.jk.rho   r.jh.rho       r.kh \n#&gt;  0.4436352 -0.4013063 -0.6206376\n\n\nMoisture indicators (positive association). Humidity3pm (\\(r = 0.44\\)) and cloud cover (\\(r \\approx 0.37\\)) show the strongest positive associations. High afternoon humidity indicates moisture has accumulated in the lower atmosphere over the course of the day. Cloud cover is both a physical precondition for rain and a consequence of the same atmospheric dynamics.\nRadiation and evaporation indicators (negative association). Sunshine (\\(r = -0.40\\)) and evaporation (\\(r = -0.31\\)) exhibit the strongest negative associations. Long sunshine hours proxy clear-sky, high-pressure conditions. High evaporation signals warm, dry, low-humidity surface conditions.\nMulticollinearity. The correlation heatmap (Figure 3.1) reveals substantial redundancy among predictors. pressure9am and pressure3pm share \\(r = 0.96\\), and the two temperature readings are similarly collinear. This directly motivates VIF-based feature selection in the feature engineering chapter.\nStatistical validation. Steiger’s Z-test comparing the two strongest opposing predictors yields \\(z \\approx 188.9\\), \\(p &lt; 2.2 \\times 10^{-16}\\). With \\(N &gt; 140,000\\), the p-value alone is uninformative; the Z-statistic magnitude confirms the differential predictive strength is not a sampling artefact. Humidity and sunshine represent genuinely distinct physical forces operating in opposing directions.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#temporal-structure-of-rainfall",
    "href": "03-eda.html#temporal-structure-of-rainfall",
    "title": "3  Exploratory Data Analysis",
    "section": "3.5 Temporal Structure of Rainfall",
    "text": "3.5 Temporal Structure of Rainfall\n\n3.5.1 Weekly and Seasonal Frequency\n\n\nShow the code\ndf_clean %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  tabyl(day) %&gt;%\n  adorn_pct_formatting() %&gt;%\n  arrange(desc(n)) %&gt;%\n  kable(\n    caption = \"Frequency of Rainfall Days by Day of the Week\",\n    col.names = c(\"Day\", \"Count (n)\", \"Percentage\")\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nFrequency of Rainfall Days by Day of the Week\n\n\nDay\nCount (n)\nPercentage\n\n\n\n\nTue\n7508\n14.7%\n\n\nMon\n7480\n14.6%\n\n\nFri\n7378\n14.4%\n\n\nWed\n7342\n14.4%\n\n\nThu\n7314\n14.3%\n\n\nSat\n7057\n13.8%\n\n\nSun\n7040\n13.8%\n\n\n\n\n\nShow the code\ndf_clean %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  tabyl(month) %&gt;%\n  adorn_pct_formatting() %&gt;%\n  arrange(desc(n)) %&gt;%\n  kable(\n    caption = \"Frequency of Rainfall Days by Month\",\n    col.names = c(\"Month\", \"Count (n)\", \"Percentage\")\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nFrequency of Rainfall Days by Month\n\n\nMonth\nCount (n)\nPercentage\n\n\n\n\n6\n5448\n10.7%\n\n\n7\n5250\n10.3%\n\n\n5\n4937\n9.7%\n\n\n8\n4704\n9.2%\n\n\n3\n4444\n8.7%\n\n\n9\n4234\n8.3%\n\n\n4\n4001\n7.8%\n\n\n10\n3770\n7.4%\n\n\n11\n3760\n7.4%\n\n\n1\n3702\n7.2%\n\n\n12\n3562\n7.0%\n\n\n2\n3307\n6.5%\n\n\n\n\n\nShow the code\ndf_clean %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  tabyl(month, day) %&gt;%\n  adorn_totals(c(\"row\", \"col\")) %&gt;%\n  kable(caption = \"Cross-tabulation of Rainfall Frequency: Month vs. Day\") %&gt;%\n  kable_styling(\n    bootstrap_options = c(\"striped\", \"condensed\"),\n    font_size = 11\n  ) %&gt;%\n  scroll_box(width = \"100%\")\n\n\n\n\nCross-tabulation of Rainfall Frequency: Month vs. Day\n\n\nmonth\nSun\nMon\nTue\nWed\nThu\nFri\nSat\nTotal\n\n\n\n\n1\n536\n570\n514\n482\n493\n567\n540\n3702\n\n\n2\n480\n530\n469\n466\n443\n471\n448\n3307\n\n\n3\n636\n645\n639\n592\n662\n644\n626\n4444\n\n\n4\n578\n597\n566\n604\n579\n515\n562\n4001\n\n\n5\n710\n722\n765\n714\n678\n681\n667\n4937\n\n\n6\n766\n801\n804\n797\n760\n753\n767\n5448\n\n\n7\n694\n717\n728\n796\n773\n818\n724\n5250\n\n\n8\n612\n702\n694\n679\n689\n687\n641\n4704\n\n\n9\n516\n571\n616\n639\n648\n659\n585\n4234\n\n\n10\n507\n606\n579\n550\n517\n456\n555\n3770\n\n\n11\n556\n526\n554\n480\n538\n575\n531\n3760\n\n\n12\n449\n493\n580\n543\n534\n552\n411\n3562\n\n\nTotal\n7040\n7480\n7508\n7342\n7314\n7378\n7057\n51119\n\n\n\n\n\n\nWeekly cycle. The distribution of wet days across the days of the week is approximately uniform, ranging from 13.8% to 14.7%. This near-uniformity is physically expected: atmospheric processes operate independently of the social calendar. The slight variation is consistent with sampling noise, suggesting Day carries little predictive information.\nAnnual cycle. June (10.7%) and July (10.3%) record the highest frequency of wet days, consistent with Southern Hemisphere winter frontal systems from the Southern Ocean. February (6.5%) and December (7.0%) record the lowest frequencies. The cross-tabulation confirms this seasonal signal is not an artefact of any particular day of the week. Month is therefore a legitimate predictor warranting explicit model inclusion.\n\n\n3.5.2 Day-to-Day Persistence: A Markov Chain Analysis\n\n\nShow the code\nmarkov_table &lt;- df_final %&gt;%\n  group_by(location) %&gt;%\n  arrange(date) %&gt;%\n  mutate(yesterday_rain = lag(rain_today)) %&gt;%\n  ungroup() %&gt;%\n  filter(!is.na(rain_today), !is.na(yesterday_rain)) %&gt;%\n  count(yesterday_rain, rain_today)\n\ncont_table &lt;- markov_table %&gt;%\n  pivot_wider(names_from = rain_today, values_from = n, values_fill = 0) %&gt;%\n  column_to_rownames(\"yesterday_rain\") %&gt;%\n  as.matrix()\n\nprint(cont_table)\n\n\n#&gt;        No   Yes\n#&gt; No  93231 17043\n#&gt; Yes 17047 14829\n\n\n\n\nShow the code\nchi_result &lt;- chisq_test(as.table(cont_table))\nprint(chi_result)\n#&gt; # A tibble: 1 × 6\n#&gt;        n statistic     p    df method          p.signif\n#&gt; *  &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;   \n#&gt; 1 142150    13718.     0     1 Chi-square test ****\n\ncramers_v &lt;- cramer_v(cont_table)\n\ncat(\"\\nEffect Size Interpretation\\n\")\n#&gt; \n#&gt; Effect Size Interpretation\ncat(sprintf(\"V = %.4f: \", cramers_v))\n#&gt; V = 0.3107:\n\nif (cramers_v &lt; 0.1) {\n  cat(\"Negligible Association\\n\")\n} else if (cramers_v &lt; 0.3) {\n  cat(\"Weak Association\\n\")\n} else if (cramers_v &lt; 0.5) {\n  cat(\"Moderate Association\\n\")\n} else {\n  cat(\"Strong Association\\n\")\n}\n#&gt; Moderate Association\n\n\n\n\nShow the code\nmarkov_data &lt;- df_final %&gt;%\n  group_by(location) %&gt;%\n  arrange(date) %&gt;%\n  mutate(yesterday_rain = lag(rain_today)) %&gt;%\n  ungroup() %&gt;%\n  filter(!is.na(rain_today), !is.na(yesterday_rain))\n\nmarkov_data %&gt;%\n  count(yesterday_rain, rain_today) %&gt;%\n  group_by(yesterday_rain) %&gt;%\n  mutate(prob = n / sum(n)) %&gt;%\n  ggplot(aes(x = yesterday_rain, y = rain_today, fill = prob)) +\n  geom_tile() +\n  geom_text(\n    aes(label = scales::percent(prob, accuracy = 1)),\n    color = \"white\",\n    size = 8,\n    fontface = \"bold\"\n  ) +\n  scale_fill_viridis_c(option = \"viridis\", begin = 0.2, end = 0.8) +\n  labs(\n    title = \"Markov Chain: Rain Persistence Effect\",\n    subtitle = sprintf(\n      \"X^2 = %.2f, p &lt; 0.001, Cramer's V = %.3f (Moderate Association)\\nYesterday's rain state is a significant, moderate predictor of today's rain state.\",\n      chi_result$statistic,\n      cramers_v\n    ),\n    x = \"Did it Rain Yesterday?\",\n    y = \"Did it Rain Today?\",\n    fill = \"Probability\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text = element_text(size = 12),\n    axis.title = element_text(size = 14, face = \"bold\"),\n    plot.title = element_text(size = 16, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\nFigure 3.2: Markov Chain Transition Matrix. The asymmetry between dry-to-dry (85%) and wet-to-wet (47%) probabilities is the central finding: dry states are self-reinforcing, wet states are transient.\n\n\n\n\n\nThe Chi-squared test yields \\(\\chi^2 \\approx 13,718\\), \\(p &lt; 0.001\\), rejecting daily independence by a large margin. Cramer’s V (\\(V \\approx 0.31\\)) confirms a moderate practical effect size.\nThe transition matrix (Figure 3.2) reveals an important asymmetry. When the previous day was dry, there is an 85% probability of remaining dry, high-pressure systems are persistent and self-reinforcing. When the previous day was wet, there is only a 47% probability of continued rain, meaning wet events are more transient. This asymmetry has a direct atmospheric interpretation: anticyclonic systems can persist for days to weeks, while frontal systems pass through more quickly.\nrain_today (lagged one day) carries meaningful predictive signal. Its modest effect size also demonstrates that autocorrelation alone is insufficient: the wet state is too transient for a persistence-only rule, and other meteorological covariates are necessary.\n\n\n3.5.3 Dry Spell Dynamics and Temporal Decay\n\n\nShow the code\ndry_spell_data &lt;- df_final %&gt;%\n  group_by(location) %&gt;%\n  arrange(date) %&gt;%\n  mutate(\n    did_rain_yesterday = lag(rainfall &gt; 0, default = FALSE),\n    dry_spell_id = cumsum(did_rain_yesterday)\n  ) %&gt;%\n  group_by(location, dry_spell_id) %&gt;%\n  mutate(days_since_rain = row_number()) %&gt;%\n  ungroup() %&gt;%\n  filter(days_since_rain &lt;= 30) %&gt;%\n  mutate(rain_binary = as.numeric(rainfall &gt; 0))\n\n\n\n\nShow the code\nlogit_model &lt;- glm(\n  rain_binary ~ days_since_rain,\n  data = dry_spell_data,\n  family = binomial(link = \"logit\")\n)\n\nwald_test &lt;- aod::wald.test(\n  b = coef(logit_model),\n  Sigma = vcov(logit_model),\n  Terms = 2\n)\nor_results &lt;- tidy(logit_model, conf.int = TRUE, exponentiate = TRUE) %&gt;%\n  filter(term == \"days_since_rain\")\n\nprint(wald_test)\n#&gt; Wald test:\n#&gt; ----------\n#&gt; \n#&gt; Chi-squared test:\n#&gt; X2 = 8099.7, df = 1, P(&gt; X2) = 0.0\ncat(sprintf(\n  \"\\nFor each additional day without rain, odds of rainfall decrease by %.1f%%\\n\",\n  (1 - or_results$estimate) * 100\n))\n#&gt; \n#&gt; For each additional day without rain, odds of rainfall decrease by 16.5%\ncat(sprintf(\n  \"95%% CI: [%.3f, %.3f]\\n\",\n  or_results$conf.low,\n  or_results$conf.high\n))\n#&gt; 95% CI: [0.831, 0.838]\n\n\n\n\nShow the code\nlogit_spline &lt;- glm(\n  rain_binary ~ splines::ns(days_since_rain, df = 4),\n  data = dry_spell_data,\n  family = binomial\n)\n\nlrt_result &lt;- anova(logit_model, logit_spline, test = \"LRT\")\nprint(lrt_result)\n#&gt; Analysis of Deviance Table\n#&gt; \n#&gt; Model 1: rain_binary ~ days_since_rain\n#&gt; Model 2: rain_binary ~ splines::ns(days_since_rain, df = 4)\n#&gt;   Resid. Df Resid. Dev Df Deviance  Pr(&gt;Chi)    \n#&gt; 1    138444     169706                          \n#&gt; 2    138441     162027  3   7678.7 &lt; 2.2e-16 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\nShow the code\npred_data &lt;- data.frame(days_since_rain = 1:30)\npred_data$pred_prob &lt;- predict(\n  logit_model,\n  newdata = pred_data,\n  type = \"response\"\n)\npred_data$pred_se &lt;- predict(\n  logit_model,\n  newdata = pred_data,\n  type = \"response\",\n  se.fit = TRUE\n)$se.fit\n\nempirical_probs &lt;- dry_spell_data %&gt;%\n  group_by(days_since_rain) %&gt;%\n  summarise(\n    prob_rain = mean(rain_binary, na.rm = TRUE),\n    n = n(),\n    se = sqrt(prob_rain * (1 - prob_rain) / n)\n  )\n\nggplot() +\n  geom_ribbon(\n    data = pred_data,\n    aes(\n      x = days_since_rain,\n      ymin = pred_prob - 1.96 * pred_se,\n      ymax = pred_prob + 1.96 * pred_se\n    ),\n    alpha = 0.2,\n    fill = \"firebrick\"\n  ) +\n  geom_line(\n    data = pred_data,\n    aes(x = days_since_rain, y = pred_prob),\n    color = \"firebrick\",\n    size = 1.2,\n    linetype = \"dashed\"\n  ) +\n  geom_pointrange(\n    data = empirical_probs,\n    aes(\n      x = days_since_rain,\n      y = prob_rain,\n      ymin = prob_rain - 1.96 * se,\n      ymax = prob_rain + 1.96 * se\n    ),\n    size = 0.5,\n    color = \"black\"\n  ) +\n  scale_y_continuous(\n    labels = scales::percent_format(1),\n    breaks = pretty_breaks(n = 6)\n  ) +\n  scale_x_continuous(breaks = scales::pretty_breaks()) +\n  labs(\n    x = \"Days Since Last Rain\",\n    y = \"Probability of Rainfall\",\n    title = \"Dry Spell Effect on Rain Probability\",\n    subtitle = sprintf(\n      \"Logistic Regression: B = %.4f, Wald chi2 = %.2f, p &lt; 0.001\\nEach additional dry day reduces odds of rain by %.1f%%\",\n      coef(logit_model)[2],\n      wald_test$result$chi2[1],\n      (1 - or_results$estimate) * 100\n    ),\n    caption = \"Points: Empirical probabilities +/- 95% CI | Line: Logistic model fit\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nFigure 3.3: The drying effect: empirical vs. modelled probability of rainfall by days since last rain. The rapid initial decline followed by a plateau motivates a spline parameterisation rather than a linear logistic term.\n\n\n\n\n\nA logistic regression of daily rain occurrence on days_since_rain yields \\(OR = 0.835\\) (Wald \\(\\chi^2 \\approx 8099\\), \\(p &lt; 0.001\\)): each additional dry day reduces the odds of rainfall by approximately 16.5%. This is consistent with the progressive establishment of stable high-pressure ridges documented in the Markov analysis.\nThe linear model is however an approximation. The LRT against a four-knot natural spline is highly significant (\\(\\chi^2 \\approx 7678\\), \\(p &lt; 0.001\\)). The empirical pattern (Figure 3.3) shows rain probability falling sharply from approximately 48% on Day 1 to around 18% by Day 10, then plateauing in the 12-16% range through Days 15 to 30. The linear model underestimates the initial steepness and overestimates long-drought decline rates. This “rapid-then-gradual” decay motivates a spline parameterisation of days_since_rain rather than a simple linear term.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#atmospheric-pressure-dynamics",
    "href": "03-eda.html#atmospheric-pressure-dynamics",
    "title": "3  Exploratory Data Analysis",
    "section": "3.6 Atmospheric Pressure Dynamics",
    "text": "3.6 Atmospheric Pressure Dynamics\n\n\nShow the code\npressure_data &lt;- df_final %&gt;%\n  mutate(pressure_change = pressure3pm - pressure9am) %&gt;%\n  select(rain_today, pressure9am, pressure3pm, pressure_change) %&gt;%\n  filter(!is.na(pressure9am), !is.na(rain_today))\n\npressure_data %&gt;%\n  sample_n(5000) %&gt;%\n  pivot_longer(\n    cols = c(pressure9am, pressure3pm, pressure_change),\n    names_to = \"metric\",\n    values_to = \"value\"\n  ) %&gt;%\n  ggplot(aes(sample = value)) +\n  stat_qq(alpha = 0.5) +\n  stat_qq_line(color = \"red\") +\n  facet_wrap(~metric, scales = \"free\") +\n  labs(\n    title = \"Q-Q Plots: Normality Check for Pressure Variables\",\n    subtitle = \"Modest tail deviations acceptable at N &gt; 140,000 (CLT applies).\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nShow the code\ntest_data &lt;- pressure_data %&gt;%\n  pivot_longer(\n    cols = c(pressure9am, pressure3pm, pressure_change),\n    names_to = \"metric\",\n    values_to = \"value\"\n  )\n\nstats_results &lt;- test_data %&gt;%\n  group_by(metric) %&gt;%\n  t_test(value ~ rain_today, var.equal = FALSE) %&gt;%\n  adjust_pvalue(method = \"holm\") %&gt;%\n  add_significance()\n\nstats_results %&gt;%\n  select(metric, group1, group2, statistic, df, p.adj, p.adj.signif) %&gt;%\n  kable(\n    caption = \"Welch Two-Sample t-test Results (Bonferroni-Holm Corrected)\",\n    digits = 3,\n    col.names = c(\n      \"Metric\",\n      \"Group 1\",\n      \"Group 2\",\n      \"t-statistic\",\n      \"df\",\n      \"Adj. P-Value\",\n      \"Significance\"\n    )\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nWelch Two-Sample t-test Results (Bonferroni-Holm Corrected)\n\n\nMetric\nGroup 1\nGroup 2\nt-statistic\ndf\nAdj. P-Value\nSignificance\n\n\n\n\npressure3pm\nNo\nYes\n34.844\n47909.59\n0\n****\n\n\npressure9am\nNo\nYes\n58.520\n49181.95\n0\n****\n\n\npressure_change\nNo\nYes\n-54.085\n50668.58\n0\n****\n\n\n\n\n\n\n\nShow the code\neffect_sizes &lt;- test_data %&gt;%\n  group_by(metric) %&gt;%\n  cohens_d(value ~ rain_today, var.equal = FALSE) %&gt;%\n  mutate(\n    magnitude = case_when(\n      abs(effsize) &lt; 0.2 ~ \"Negligible\",\n      abs(effsize) &lt; 0.5 ~ \"Small\",\n      abs(effsize) &lt; 0.8 ~ \"Medium\",\n      TRUE ~ \"Large\"\n    )\n  )\n\neffect_sizes %&gt;%\n  select(metric, effsize, magnitude) %&gt;%\n  kable(\n    caption = \"Cohen's d Effect Size Analysis\",\n    digits = 3,\n    col.names = c(\"Metric\", \"Effect Size (d)\", \"Interpretation\")\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nCohen's d Effect Size Analysis\n\n\nMetric\nEffect Size (d)\nInterpretation\n\n\n\n\npressure3pm\n0.228\nSmall\n\n\npressure9am\n0.379\nSmall\n\n\npressure_change\n-0.346\nSmall\n\n\n\n\n\n\n\nShow the code\nplot_annotations &lt;- stats_results %&gt;%\n  left_join(effect_sizes, by = \"metric\") %&gt;%\n  mutate(\n    label_text = sprintf(\n      \"p %s\\nCohen's d = %.2f (%s)\",\n      p.adj.signif,\n      effsize,\n      magnitude\n    ),\n    y_pos = case_when(\n      metric == \"pressure9am\" ~ 1045,\n      metric == \"pressure3pm\" ~ 1040,\n      metric == \"pressure_change\" ~ 15\n    )\n  )\n\nggplot(test_data, aes(rain_today, value, fill = rain_today)) +\n  geom_violin(alpha = 0.6, trim = TRUE) +\n  geom_boxplot(width = 0.2, outlier.shape = NA, alpha = 0.8, color = \"black\") +\n  facet_wrap(~metric, scales = \"free_y\") +\n  geom_text(\n    data = plot_annotations,\n    aes(x = 1.5, y = y_pos, label = label_text),\n    inherit.aes = FALSE,\n    vjust = 0,\n    fontface = \"italic\",\n    size = 3.5\n  ) +\n  scale_fill_manual(values = c(\"No\" = \"#B0B0B0\", \"Yes\" = \"#0072B2\")) +\n  labs(\n    title = \"Atmospheric Pressure vs. Rainfall\",\n    subtitle = \"Welch's t-test with Cohen's d effect sizes\",\n    y = \"Pressure (hPa)\",\n    x = \"Did it rain?\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    strip.text = element_text(size = 12, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\nFigure 3.4: Violin plots of atmospheric pressure variables by rainfall state. The pressure_change panel shows the most pronounced separation.\n\n\n\n\n\n\n\nShow the code\ndata_wide &lt;- df_final %&gt;%\n  group_by(rain_today) %&gt;%\n  summarise(\n    `9:00 AM` = mean(pressure9am, na.rm = TRUE),\n    `3:00 PM` = mean(pressure3pm, na.rm = TRUE),\n    `Pressure Drop` = mean(pressure9am, na.rm = TRUE) -\n      mean(pressure3pm, na.rm = TRUE)\n  ) %&gt;%\n  pivot_longer(cols = -rain_today, names_to = \"metric\", values_to = \"value\") %&gt;%\n  mutate(\n    metric = factor(metric, levels = c(\"9:00 AM\", \"3:00 PM\", \"Pressure Drop\")),\n    label_txt = round(value, 1)\n  )\n\nggplot(data_wide, aes(x = rain_today, y = value, fill = rain_today)) +\n  geom_col(width = 0.6, alpha = 0.9) +\n  geom_text(aes(label = label_txt), vjust = -0.5, fontface = \"bold\", size = 4) +\n  facet_wrap(~metric, scales = \"free_y\", nrow = 1) +\n  scale_fill_manual(values = c(\"No\" = \"#B0B0B0\", \"Yes\" = \"#0072B2\")) +\n  scale_x_discrete(labels = c(\"No\" = \"Dry Days\", \"Yes\" = \"Rainy Days\")) +\n  labs(\n    title = \"Rainy Days Show Lower Baseline Pressure and Suppressed Diurnal Variation\",\n    subtitle = \"The diurnal pressure drop is the stronger discriminating signal\",\n    y = \"Pressure (hPa) / Drop (hPa)\",\n    x = NULL\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(face = \"bold\", size = 12),\n    axis.text.x = element_text(face = \"bold\", size = 11),\n    strip.text = element_text(face = \"bold\", size = 12),\n    panel.grid.major.x = element_blank()\n  )\n\n\n\n\n\n\n\n\nFigure 3.5: Mean pressure levels and diurnal drop by rainfall state. The suppressed pressure drop on rainy days (1.3 vs. 2.7 hPa) is a stronger discriminating signal than the absolute pressure baseline.\n\n\n\n\n\nNormality. Q-Q plots show modest tail deviations, but with \\(N &gt; 140,000\\) the CLT ensures normally distributed sample means. Welch’s t-test is therefore valid without equal-variance assumptions, and Bonferroni-Holm correction is applied for multiple comparisons.\nBaseline pressure. Rainy days show mean pressure of 1015 hPa at 9:00 AM versus 1018.5 hPa on dry days. Cohen’s \\(d \\approx 0.28\\)-\\(0.48\\) represents a small-to-medium effect, consistent with absolute pressure being necessary but not sufficient for rain.\nDiurnal pressure change. On dry days, pressure drops 2.7 hPa from morning to afternoon, the standard thermal low from daytime surface heating. On rainy days, this drop is suppressed to 1.3 hPa, because cloud cover reduces insolation. Cohen’s \\(d = -0.72\\) for pressure_change is a medium effect, stronger than either absolute pressure reading individually. The rate of pressure change during the day is the more discriminating feature.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#seasonal-rainfall-intensity",
    "href": "03-eda.html#seasonal-rainfall-intensity",
    "title": "3  Exploratory Data Analysis",
    "section": "3.7 Seasonal Rainfall Intensity",
    "text": "3.7 Seasonal Rainfall Intensity\n\n3.7.1 Cyclical Patterns\n\n\nShow the code\nmonthly_stats &lt;- df_final %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n    median_rain = median(rainfall),\n    mean_rain = mean(rainfall),\n    rain_days = n(),\n    .groups = \"drop\"\n  ) %&gt;%\n  mutate(month_label = factor(month.abb[month], levels = rev(month.abb)))\n\nplot_data &lt;- df_final %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  mutate(\n    month_label = factor(month.abb[month], levels = rev(month.abb)),\n    log_rain = log(rainfall)\n  ) %&gt;%\n  left_join(monthly_stats, by = c(\"month\", \"month_label\"))\n\n\n\n\nShow the code\nggplot(plot_data, aes(log_rain, month_label, fill = after_stat(x))) +\n  geom_density_ridges_gradient(\n    scale = 2.5,\n    rel_min_height = 0.01,\n    quantile_lines = TRUE,\n    quantiles = 2,\n    alpha = 0.8\n  ) +\n  geom_vline(\n    xintercept = median(log(df_final$rainfall[df_final$rainfall &gt; 0])),\n    linetype = \"dashed\",\n    color = \"grey30\",\n    linewidth = 0.5\n  ) +\n  scale_fill_viridis_c(\n    option = \"mako\",\n    name = \"Log\\nRainfall\",\n    direction = -1\n  ) +\n  scale_x_continuous(breaks = pretty_breaks()) +\n  labs(\n    title = \"Monthly Rainfall Distribution Patterns\",\n    subtitle = \"Solid lines mark monthly medians vs. the global median (dashed).\",\n    x = \"Rainfall Amount (mm, log scale)\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 13)\n\n\n\n\n\n\n\n\nFigure 3.6: Ridgeline plot of monthly log-rainfall distributions. Shifting peaks illustrate how rainfall intensity varies cyclically relative to the global median (dashed line).\n\n\n\n\n\n\n\nShow the code\nseasonal_data &lt;- df_final %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  mutate(\n    season = case_when(\n      month %in% c(12, 1, 2) ~ \"Summer\",\n      month %in% c(3, 4, 5) ~ \"Autumn\",\n      month %in% c(6, 7, 8) ~ \"Winter\",\n      month %in% c(9, 10, 11) ~ \"Spring\"\n    ),\n    season = factor(season, levels = c(\"Summer\", \"Autumn\", \"Winter\", \"Spring\"))\n  )\n\nseasonal_data %&gt;%\n  mutate(month_label = factor(month.abb[month], levels = month.abb)) %&gt;%\n  ggplot(aes(rainfall, month_label, fill = season)) +\n  geom_density_ridges(\n    scale = 1.5,\n    alpha = 0.7,\n    quantile_lines = TRUE,\n    quantiles = c(0.25, 0.5, 0.75)\n  ) +\n  scale_x_log10(\n    breaks = c(1, 10, 50, 100, 300),\n    labels = label_number(accuracy = 1)\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Summer\" = \"#E69F00\",\n      \"Autumn\" = \"#D55E00\",\n      \"Winter\" = \"#0072B2\",\n      \"Spring\" = \"#009E73\"\n    )\n  ) +\n  facet_wrap(~season, scales = \"free_y\", ncol = 2) +\n  labs(\n    title = \"Seasonal Rainfall Patterns\",\n    subtitle = \"Quartile lines show 25th, 50th, and 75th percentiles\",\n    x = \"Rainfall Amount (mm, log scale)\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12)\n\n\n\n\n\n\n\n\nFigure 3.7: Seasonal rainfall patterns by meteorological season. Summer exhibits high variance and a pronounced right tail; winter shows narrower, more predictable distributions.\n\n\n\n\n\n\n\nShow the code\nmonthly_stats %&gt;%\n  mutate(month_label = factor(month.abb[month], levels = month.abb)) %&gt;%\n  ggplot(aes(month_label, mean_rain)) +\n  geom_col(aes(fill = mean_rain, alpha = 0.8), width = 0.7) +\n  geom_text(\n    aes(label = round(mean_rain, 1)),\n    vjust = -0.5,\n    size = 3.5,\n    fontface = \"bold\"\n  ) +\n  scale_fill_viridis_c(option = \"mako\", direction = -1) +\n  labs(\n    title = \"Mean Rainfall by Month (Non-Zero Days)\",\n    subtitle = \"Seasonal variation in intensity is distinct from seasonal variation in frequency\",\n    y = \"Mean Rainfall (mm)\",\n    x = NULL\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    legend.position = \"none\",\n    panel.grid.major.x = element_blank(),\n    axis.text.x = element_text(angle = 45, hjust = 1, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\nFigure 3.8: Average rainfall intensity on non-zero days by month. February records the highest mean intensity at 10.1 mm, nearly double July’s 4.9 mm.\n\n\n\n\n\nThe earlier frequency analysis (Section 3.5.1) established when rain tends to occur. This section investigates how much falls when it does.\nJanuary and February distributions are shifted systematically right of the global median: summer storms are considerably more intense when they arrive, even though they occur less frequently. June through August cluster left, representing lower but more consistent rainfall. February records the highest mean intensity per wet day at 10.1 mm, nearly double July’s 4.9 mm.\nSummer rainfall has a wide interquartile range and a pronounced right tail beyond 100 mm per day, reflecting episodic convective storms. Winter shows a narrower, more peaked distribution. Both the frequency variation (more rain in winter) and the intensity variation (heavier rain in summer) carry independent information; a complete model must account for both dimensions.\nEncoding implication. Because the seasonal cycle is continuous the transition from December to January is climatologically smooth treating Month as unordered discards proximity information. Cyclical encoding via sine and cosine transformations of the month number preserves the circular geometry of the annual cycle.\n\n\n3.7.2 Statistical Validation\n\n\nShow the code\nseasonal_data %&gt;%\n  select(season, rainfall) %&gt;%\n  group_by(season) %&gt;%\n  get_summary_stats(rainfall, type = \"mean_sd\") %&gt;%\n  kable(\n    caption = \"Descriptive Statistics of Rainfall Intensity by Season\",\n    col.names = c(\"Season\", \"Variable\", \"N (Events)\", \"Mean (mm)\", \"SD (mm)\")\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nDescriptive Statistics of Rainfall Intensity by Season\n\n\nSeason\nVariable\nN (Events)\nMean (mm)\nSD (mm)\n\n\n\n\nSummer\nrainfall\n10571\n9.070\n18.195\n\n\nAutumn\nrainfall\n13382\n6.667\n13.495\n\n\nWinter\nrainfall\n15402\n5.463\n9.809\n\n\nSpring\nrainfall\n11764\n5.651\n10.495\n\n\n\n\n\n\n\nShow the code\nkw_result &lt;- kruskal_test(rainfall ~ season, data = seasonal_data)\nepsilon_sq &lt;- kruskal_effsize(rainfall ~ season, data = seasonal_data)\n\ntibble(\n  Test = \"Kruskal-Wallis Rank Sum Test\",\n  `Chi-squared` = round(kw_result$statistic, 2),\n  df = kw_result$df,\n  `P-value` = scales::pvalue(kw_result$p, accuracy = 0.001),\n  `Effect Size` = round(epsilon_sq$effsize, 4),\n  Magnitude = as.character(epsilon_sq$magnitude)\n) %&gt;%\n  kable(\n    caption = \"Statistical Significance of Seasonal Differences (Non-Parametric)\",\n    align = \"lccccr\"\n  ) %&gt;%\n  kable_styling(\n    bootstrap_options = c(\"striped\", \"hover\", \"condensed\"),\n    full_width = FALSE,\n    position = \"left\"\n  ) %&gt;%\n  add_footnote(\n    c(\"Effect size: Epsilon-squared.\", \"Alpha = 0.05\"),\n    notation = \"symbol\"\n  )\n\n\n\nStatistical Significance of Seasonal Differences (Non-Parametric)\n\n\nTest\nChi-squared\ndf\nP-value\nEffect Size\nMagnitude\n\n\n\n\nKruskal-Wallis Rank Sum Test\n230.44\n3\n&lt;0.001\n0.0044\nsmall\n\n\n\n* Effect size: Epsilon-squared.\n\n\n\n\n\n\n\n† Alpha = 0.05\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow the code\ndunn_result &lt;- dunn_test(\n  rainfall ~ season,\n  data = seasonal_data,\n  p.adjust.method = \"bonferroni\"\n)\n\ndunn_result %&gt;%\n  select(group1, group2, statistic, p.adj, p.adj.signif) %&gt;%\n  kable(\n    caption = \"Dunn's Pairwise Comparison Test (Bonferroni Corrected)\",\n    col.names = c(\n      \"Group 1\",\n      \"Group 2\",\n      \"Z-Statistic\",\n      \"Adj. P-Value\",\n      \"Significance\"\n    )\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nDunn's Pairwise Comparison Test (Bonferroni Corrected)\n\n\nGroup 1\nGroup 2\nZ-Statistic\nAdj. P-Value\nSignificance\n\n\n\n\nSummer\nAutumn\n-11.4684561\n0.0000000\n****\n\n\nSummer\nWinter\n-14.4832877\n0.0000000\n****\n\n\nSummer\nSpring\n-11.0494713\n0.0000000\n****\n\n\nAutumn\nWinter\n-2.8512817\n0.0261260\n*\n\n\nAutumn\nSpring\n0.0912015\n1.0000000\nns\n\n\nWinter\nSpring\n2.8459539\n0.0265672\n*\n\n\n\n\n\n\n\nShow the code\np_vals &lt;- dunn_result$p.adj\nnames(p_vals) &lt;- paste(dunn_result$group1, dunn_result$group2, sep = \"-\")\nletters_vec &lt;- multcompLetters(p_vals)$Letters\nletters_df &lt;- data.frame(season = names(letters_vec), Letter = letters_vec)\n\nseasonal_data %&gt;%\n  group_by(season) %&gt;%\n  summarise(mean_rain = mean(rainfall, na.rm = TRUE), n = n()) %&gt;%\n  left_join(letters_df, by = \"season\") %&gt;%\n  ggplot(aes(x = season, y = mean_rain, fill = season)) +\n  geom_col(alpha = 0.8, width = 0.7) +\n  geom_text(aes(label = Letter), vjust = -0.5, size = 8, fontface = \"bold\") +\n  geom_text(\n    aes(label = round(mean_rain, 1)),\n    vjust = 1.5,\n    color = \"white\",\n    fontface = \"bold\",\n    size = 5\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Summer\" = \"#E69F00\",\n      \"Autumn\" = \"#D55E00\",\n      \"Winter\" = \"#0072B2\",\n      \"Spring\" = \"#009E73\"\n    )\n  ) +\n  labs(\n    title = \"Seasonal Rainfall with Statistical Groupings\",\n    subtitle = sprintf(\n      \"Kruskal-Wallis: p &lt; 0.001, Effect Size: %s\\nSeasons sharing a letter are not significantly different.\",\n      as.character(epsilon_sq$magnitude)\n    ),\n    y = \"Mean Rainfall (mm)\",\n    x = NULL\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(face = \"bold\", size = 16),\n    axis.text.x = element_text(size = 12, face = \"bold\"),\n    panel.grid.major.x = element_blank()\n  )\n\n\n\n\n\n\n\n\nFigure 3.9: Mean seasonal rainfall with statistical groupings. Shared letters indicate seasons not significantly different from one another (Dunn’s test, p &lt; 0.05).\n\n\n\n\n\nThe Kruskal-Wallis test yields \\(\\chi^2 = 230\\), \\(p &lt; 0.001\\), strongly rejecting the null. The epsilon-squared effect size (\\(\\eta^2 \\approx 0.004\\)) is small the seasonal signal is real but accounts for only a minor fraction of total variance in rainfall intensity, reinforcing the necessity of a multivariate approach.\nPost-hoc Dunn’s tests identify three distinct statistical groups (Figure 3.9). Summer stands alone as the most intense season (\\(\\bar{x} = 9.1\\) mm, \\(p &lt; 0.001\\) vs. all others). Autumn and Spring are statistically indistinguishable (\\(p = 1.0\\)). Winter registers the lowest mean intensity (\\(\\bar{x} = 5.5\\) mm) and is statistically distinct from Spring (\\(p_\\text{adj} = 0.026\\)).",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#sec-bivariate-density",
    "href": "03-eda.html#sec-bivariate-density",
    "title": "3  Exploratory Data Analysis",
    "section": "3.8 Feature Interactions: The “Rain Corner”",
    "text": "3.8 Feature Interactions: The “Rain Corner”\n\n\nShow the code\ndf_final %&gt;%\n  group_by(location) %&gt;%\n  arrange(date) %&gt;%\n  mutate(rain_index_ref = ifelse(rainfall &gt; 0, row_number(), NA_integer_)) %&gt;%\n  fill(rain_index_ref, .direction = \"down\") %&gt;%\n  mutate(days_since_rain = row_number() - lag(rain_index_ref)) %&gt;%\n  select(-rain_index_ref) %&gt;%\n  ggplot(aes(sunshine, humidity3pm)) +\n  geom_density2d_filled(continuous_var = \"ndensity\", bins = 7) +\n  facet_wrap(~rain_today, labeller = label_both) +\n  scale_fill_brewer(palette = \"Blues\") +\n  labs(\n    title = \"Justifying Interaction: The 'Rain Corner'\",\n    subtitle = \"Rain (right panel) concentrates in high humidity / low sunshine.\\nDry days (left panel) are dispersed across feature space.\\nThis structural asymmetry justifies a sunshine * humidity interaction term.\",\n    x = \"Sunshine (hours)\",\n    y = \"Humidity 3pm (%)\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    strip.text = element_text(size = 12, face = \"bold\"),\n    plot.title = element_text(size = 14, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\nFigure 3.10: Bivariate density of Humidity3pm vs. Sunshine, faceted by rainfall occurrence. Rain events concentrate tightly in the upper-left ‘Rain Corner’ (high humidity, low sunshine), while dry days are dispersed broadly. This structural asymmetry justifies a multiplicative interaction term.\n\n\n\n\n\nThe correlation analysis in Section 3.4 established that humidity and sunshine are individually among the strongest predictors. A standard additive model treats their effects as independent. This section tests whether that assumption holds.\nThe bivariate density plots (Figure 3.10) reveal a striking structural difference. On dry days, the density is dispersed broadly across the humidity-sunshine space: high humidity can occur without rain under high-pressure suppression, and low sunshine can occur without rain under thin overcast. No single region clearly separates the two states.\nOn rainy days, the density collapses into a tight cluster in the upper-left quadrant: high afternoon humidity (above approximately 50%) combined with low sunshine (below approximately 5 hours). This is the “Rain Corner”. Neither condition alone is sufficient; both must coincide simultaneously. This is statistical interaction: the effect of one variable on the outcome is conditional on the level of the other.\nModelling implication. An additive model that includes Humidity3pm and Sunshine as separate terms cannot express the idea that their joint occurrence not their individual magnitudes is what matters. Capturing the Rain Corner requires a multiplicative interaction term (\\(\\text{Humidity} \\times \\text{Sunshine}\\)) in the model specification.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "03-eda.html#summary-and-modelling-implications",
    "href": "03-eda.html#summary-and-modelling-implications",
    "title": "3  Exploratory Data Analysis",
    "section": "3.9 Summary and Modelling Implications",
    "text": "3.9 Summary and Modelling Implications\nThe preceding analyses characterise the dataset along six interconnected dimensions, each producing a specific modelling requirement.\nThe distributional structure of the target variable 64% zeros, extreme positive skew, kurtosis of 181 rules out any single-component Gaussian model. A two-part framework separating occurrence from intensity is the appropriate response.\nThe missingness analysis (documented in Chapter 2, summarised in Section 1 above) establishes that imputation is necessary to preserve both sample size and the predictive signal in sunshine and evaporation, and that the imputed values do not introduce outcome-related bias.\nThe correlation structure identifies humidity, cloud cover, sunshine, and evaporation as the strongest individual predictors, and flags severe multicollinearity among morning-afternoon pairs. VIF-based feature selection is required.\nThe temporal analyses establish that both the day-to-day Markov state and the cumulative dry spell duration carry predictive signal. Month should be cyclically encoded. The dry spell decay is non-linear and warrants a natural spline parameterisation of days_since_rain.\nThe pressure analysis identifies the diurnal pressure change as the more discriminating pressure-derived feature, with Cohen’s \\(d = 0.72\\) separating rainy from dry days more effectively than absolute pressure level.\nThe interaction analysis provides empirical justification for a \\(\\text{Humidity} \\times \\text{Sunshine}\\) interaction term, reflecting the physical reality that precipitation concentrates where high moisture and low solar radiation coincide in the “Rain Corner” of the feature space.",
    "crumbs": [
      "Data",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploratory Data Analysis</span>"
    ]
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Why Standard Models Fail\nRainfall in Australia is a problem of statistical extremes. The continent experiences some of the most pronounced hydrological variability on Earth: years of crippling drought give way to sudden, widespread flooding, driven by large-scale climate oscillations including the El Nino-Southern Oscillation and the Indian Ocean Dipole. For any predictive model, this variability is not background noise to be absorbed but a central structural feature to be represented.\nThe core challenge is that precipitation data violates the assumptions of standard regression in three simultaneous ways, each of which requires a distinct methodological response. This report develops a framework that addresses all three, building from first principles through empirical analysis to a validated hierarchical model.\nEach of these violations is not merely a statistical inconvenience. Each reflects a physical property of the atmosphere: the discrete threshold between no-precipitation and precipitation conditions, the stochastic intensity of convective and frontal systems once that threshold is crossed, and the temporal persistence of synoptic weather regimes. A model that ignores these properties is not a simplification of the problem; it is a misspecification of it.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-intro.html#why-standard-models-fail",
    "href": "01-intro.html#why-standard-models-fail",
    "title": "1  Introduction",
    "section": "",
    "text": "NoteThree Structural Violations in Australian Rainfall Data\n\n\n\nZero-inflation. Approximately 64% of daily observations record exactly zero rainfall. A Gaussian linear model fitted to this data is forced to place probability mass on negative values in order to fit the bulk of the distribution correctly, producing predictions that are physically impossible. This is not a problem of outliers or transformations; it is a consequence of the data-generating process having two qualitatively different states.\nHeavy right tail. When rain does fall, the distribution of daily amounts is severely right-skewed, with a kurtosis of 181 and a maximum recorded value of 371 mm. The variance is approximately sixteen times the square of the mean. Standard models that assume a symmetric or light-tailed error distribution will systematically underestimate both the probability and the magnitude of extreme events.\nTemporal dependence. Daily observations are not independent. Whether it rained yesterday is one of the strongest predictors of whether it will rain today, with a transition probability of 47% from wet to wet compared to only 15% from dry to wet. Any model that treats consecutive observations as exchangeable ignores a substantial and recoverable source of predictive information.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-intro.html#the-modelling-framework",
    "href": "01-intro.html#the-modelling-framework",
    "title": "1  Introduction",
    "section": "1.2 The Modelling Framework",
    "text": "1.2 The Modelling Framework\nThis analysis uses a Zero-Inflated Gamma (ZIG) hierarchical model. The core innovation is to treat rainfall occurrence and rainfall intensity as two distinct sub-problems with separate linear predictors, linked through a shared observation mechanism.\nThe formal structure is as follows. For each observation \\(i\\), the model defines:\n\\[P(Y_i = 0) = \\pi_i + (1 - \\pi_i) \\cdot f_\\Gamma(0 \\mid \\mu_i, \\phi)\\]\n\\[P(Y_i = y) = (1 - \\pi_i) \\cdot f_\\Gamma(y \\mid \\mu_i, \\phi), \\quad y &gt; 0\\]\nwhere \\(\\pi_i = \\text{logit}^{-1}(\\mathbf{z}_i^\\top \\boldsymbol{\\gamma})\\) governs the probability of a structurally dry day, and \\(\\mu_i = \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})\\) governs the expected intensity given that rain falls. The two predictor vectors \\(\\mathbf{z}_i\\) and \\(\\mathbf{x}_i\\) are estimated separately, allowing the atmospheric conditions that trigger rain to differ from those that determine how much falls.\n\n\n\n\n\n\nImportantWhy Not Tweedie?\n\n\n\nThe Tweedie distribution is a natural alternative for zero-inflated positive continuous data, using a compound Poisson-Gamma structure to accommodate zero values alongside a continuous positive component. It was evaluated here and rejected on empirical grounds. The exploratory analysis (see Chapter 3) demonstrates that the predictors of occurrence and the predictors of intensity are not the same: rain_yesterday and pressure_change operate primarily through the hurdle component, while wind vectors and the sunshine-humidity interaction drive the conditional intensity. A Tweedie model constrains both to share a single linear predictor, obscuring this physical distinction and reducing interpretability without improving fit.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-intro.html#report-structure",
    "href": "01-intro.html#report-structure",
    "title": "1  Introduction",
    "section": "1.3 Report Structure",
    "text": "1.3 Report Structure\nThis document is organised as a progressive validation of modelling choices, beginning with data quality and proceeding through feature design, model construction, diagnostic testing, and formal selection. Each chapter is motivated by empirical findings from the preceding one.\n\n\n\nProject Structure and Content\n\n\nChapter\nContent\n\n\n\n\nIntroduction\nStatistical pathology of rainfall data and limitations of standard approaches.\n\n\nData\nTwo-stage imputation strategy for the 42-48% missing rate in key meteorological variables.\n\n\nEDA\nQuantification of zero-inflation, distributional properties, temporal autocorrelation, and feature interactions.\n\n\nFeature Engineering\nConstruction of wind vectors, cyclical time encoding, interaction terms, and temporal lag features.\n\n\nModelling\nProgressive construction of the ZIG model from null baseline through spatial mixed effects.\n\n\nModel Evaluation\nValidation via ROC analysis, random effects diagnostics, DHARMa simulation tests, and autocorrelation checks.\n\n\nModel Selection\nFormal comparison of distributional families, likelihood ratio tests, and variance decomposition.\n\n\nConclusion\nSummary of findings, limitations, and deployment recommendations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-intro.html#research-objectives",
    "href": "01-intro.html#research-objectives",
    "title": "1  Introduction",
    "section": "1.4 Research Objectives",
    "text": "1.4 Research Objectives\nRecover missing data without introducing bias. Instrumentation gaps affect 42-48% of observations for two of the most predictive meteorological variables. We implement a two-stage imputation strategy that combines linear temporal interpolation with multivariate Random Forest imputation via mice, using physically motivated predictor sets for each variable to fill these gaps while preserving both sample size and predictive signal.\nRepresent weather dynamics as continuous physical processes. Wind direction is circular, the annual cycle is periodic, and the joint effect of humidity and sunshine is non-linear. Standard encodings of these variables discard their structural properties. We develop features that preserve this geometry: orthogonal vector decomposition for wind direction, sine-cosine encoding for seasonality, and a mean-centred multiplicative term for the humidity-sunshine interaction.\nAccount for spatial heterogeneity. The relationship between atmospheric conditions and rainfall is not uniform across a continent as climatologically diverse as Australia. We introduce location-specific random effects that allow baseline rainfall levels and key covariate relationships to vary by station, without requiring a separate model for each location.\nValidate against the data-generating process, not just the mean. Standard accuracy metrics measure proximity to the observed mean but cannot detect distributional misspecification. We use simulation-based residual diagnostics to verify that the model replicates the full statistical distribution of Australian rainfall, including its zero-inflation rate, tail behaviour, and temporal independence structure.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Australian Rainfall Dynamics",
    "section": "",
    "text": "Predicting Australian Rainfall",
    "crumbs": [
      "Predicting Australian Rainfall"
    ]
  },
  {
    "objectID": "index.html#a-hierarchical-zero-inflated-gamma-framework-for-spatiotemporal-precipitation-modelling",
    "href": "index.html#a-hierarchical-zero-inflated-gamma-framework-for-spatiotemporal-precipitation-modelling",
    "title": "Australian Rainfall Dynamics",
    "section": "A Hierarchical Zero-Inflated Gamma Framework for Spatiotemporal Precipitation Modelling",
    "text": "A Hierarchical Zero-Inflated Gamma Framework for Spatiotemporal Precipitation Modelling",
    "crumbs": [
      "Predicting Australian Rainfall"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Australian Rainfall Dynamics",
    "section": "Overview",
    "text": "Overview\nDaily rainfall in Australia presents a statistical problem that standard regression cannot solve. Across 142,199 observations spanning the continent, 64% of days record exactly zero precipitation. When rain does fall, the distribution is severely right-skewed with a kurtosis of 181 and a maximum single-day total of 371 mm. Consecutive days are not independent: the probability of rain is 47% given rain the previous day but only 15% given a dry antecedent. And the relationship between atmospheric conditions and rainfall varies fundamentally between a tropical monsoon station in Darwin and a semi-arid inland station in Nhil.\nEach of these properties is a violation of Ordinary Least Squares assumptions. None of them can be corrected by transformation or outlier removal. They reflect the physical structure of the atmosphere: a discrete threshold between dry and wet states, a stochastic intensity process once that threshold is crossed, strong synoptic-scale persistence, and a continent spanning three distinct climate zones. The modelling framework must be built around these properties, not despite them.\nThis project implements a Mixed-Effects Zero-Inflated Gamma (ZIG) model that treats rainfall as two linked but structurally separate processes. A logistic hurdle component estimates the probability that a given day is dry, conditional on the full atmospheric state. A Gamma intensity component estimates the expected rainfall volume given that rain falls. Separate predictor sets are estimated for each component, allowing the drivers of occurrence to differ from the drivers of intensity. Location-specific random effects accommodate the spatial heterogeneity that a pooled model cannot represent.",
    "crumbs": [
      "Predicting Australian Rainfall"
    ]
  },
  {
    "objectID": "index.html#technical-highlights",
    "href": "index.html#technical-highlights",
    "title": "Australian Rainfall Dynamics",
    "section": "Technical Highlights",
    "text": "Technical Highlights\n\nData EngineeringStatistical FrameworkKey Results\n\n\nTwo-stage imputation for high-dimensional missingness. The two most predictive meteorological variables, sunshine and evaporation, are missing in 47.7% and 42.5% of records respectively due to uneven instrument deployment across the station network. Standard listwise deletion would eliminate nearly half the dataset and introduce geographic bias toward well-resourced stations. A two-stage pipeline combining linear temporal interpolation with multivariate Random Forest imputation via mice recovers these observations while preserving the marginal distributions of the imputed variables. Ghost sensor station-variable pairs, those exceeding 90% missingness across the full observation window, are identified before imputation and carried forward with binary provenance flags rather than populated with extrapolations that have no empirical anchor.\nCircular wind vector decomposition. Wind direction is a circular variable: a bearing of 359 degrees and a bearing of 1 degree are separated by 2 degrees, not 358. A naive numeric encoding treats them as maximally distant and destroys the directional information. Each compass bearing is resolved into orthogonal North-South (\\(V\\)) and East-West (\\(U\\)) components via trigonometric projection, converting a discontinuous categorical variable into two continuous physical quantities that a linear model can interpret correctly.\nTemporal signal extraction. Raw daily rainfall observations conflate the underlying weather regime with high-frequency stochastic noise. Seven-day trailing moving averages reduce the standard deviation of rainfall by 56%, from 13.1 mm to 5.8 mm, suppressing this noise and capturing a “weekly wetness regime” feature that reflects the accumulated atmospheric state preceding each observation. All moving averages are lagged by one additional day before use as predictors to prevent data leakage.\nInteraction term construction. The bivariate density analysis identified a “Rain Corner”: rainfall concentrates almost exclusively when afternoon humidity exceeds approximately 50% and daily sunshine falls below approximately five hours simultaneously. A centered multiplicative interaction term (sunshine * humidity3pm, with both variables mean-centred before multiplication) formalises this threshold. Centring reduces the variance inflation factor of the interaction term to 1.25, confirming that the artificial collinearity typically introduced by interaction terms has been eliminated.\n\n\nTwo-component mixture model. The ZIG model separates the zero mass from the positive continuous component through a logistic hurdle and a Gamma intensity submodel. The two components have independent linear predictors, allowing the atmospheric conditions that determine whether rain falls to be estimated separately from those that determine how much falls. This separation is empirically motivated: rain_yesterday and pressure_change are the dominant predictors of occurrence; wind vectors and the humidity-sunshine interaction are the dominant predictors of intensity.\nHierarchical random effects structure. Location-specific random effects are specified as uncorrelated random intercepts and slopes: \\(\\text{diag}(1 + \\text{humidity} + \\text{persistence} \\mid \\text{location})\\). This allows the baseline rainfall level, the humidity-intensity relationship, and the persistence effect to vary across the 49 weather stations in the dataset, while sharing a common global mean. The diag() structure avoids the overparameterisation of a full unstructured random covariance matrix.\nNon-linear dry spell dynamics. The EDA demonstrated that the probability of rain returning after a dry spell decays in a “rapid-then-gradual” pattern: it falls steeply over the first ten days and then stabilises. A linear logistic term for days_since_rain underestimates the initial decay and overestimates the long-run decay. A four-degree-of-freedom natural spline, \\(ns(\\text{days\\_since\\_rain},\\, df = 4)\\), is used in the zero-inflation component to capture this non-linear structure.\nEstimation and diagnostics. All models are fitted via maximum likelihood using the Template Model Builder (glmmTMB). Residual adequacy is verified using DHARMa simulation-based diagnostics, which test the scaled residuals against the theoretical uniform distribution regardless of model family. The final model passes dispersion (\\(p = 0.36\\)), zero-inflation calibration (ratio = 1.00, \\(p = 0.976\\)), and temporal autocorrelation (\\(DW = 2.0533\\), \\(p = 0.1197\\)) tests.\n\n\nThermodynamic interaction threshold. Rainfall occurrence is not a linear function of humidity or sunshine in isolation. It is gated by their simultaneous occurrence in the “Rain Corner” of the bivariate feature space, quantified through a highly significant interaction term (\\(p &lt; 0.001\\)) that is stable across all model specifications.\nMarkovian persistence. Having rained the previous day reduces the odds of today being dry by 76%, making rain_yesterday the single strongest predictor in the zero-inflation component. Weather states exhibit asymmetric stickiness: dry states are self-reinforcing (85% dry-to-dry probability) while wet states are transient (47% wet-to-wet probability).\nDirectional wind dynamics. Southerly and westerly morning wind vectors are the primary directional drivers of rainfall intensity, reflecting the influence of Southern Ocean frontal systems and the mid-latitude westerlies. Morning wind direction is three to four times more informative than peak gust direction, indicating that the provenance of the air mass matters more than its local turbulence.\nSpatial heterogeneity. After controlling for all dynamic meteorological variables, approximately 10% of total rainfall variance is attributable to location-specific baseline differences captured by the random effects. Tropical Top End stations produce roughly 1.7 to 1.8 times the rainfall of an average station at identical atmospheric conditions; arid interior stations produce approximately half as much.\nClassification performance. The zero-inflation component achieves an AUC of 0.827 and an overall accuracy of 75.28% at the Youden-optimal threshold, with a conservative error profile that generates false alarms at twice the rate of missed events.",
    "crumbs": [
      "Predicting Australian Rainfall"
    ]
  },
  {
    "objectID": "index.html#mathematical-framework",
    "href": "index.html#mathematical-framework",
    "title": "Australian Rainfall Dynamics",
    "section": "Mathematical Framework",
    "text": "Mathematical Framework\nThe model specifies that daily rainfall \\(y_i\\) follows a mixture of a point mass at zero and a Gamma-distributed positive component:\n\\[P(Y_i = 0) = \\pi_i + (1 - \\pi_i) \\cdot f_\\Gamma(0 \\mid \\mu_i,\\, \\phi)\\]\n\\[P(Y_i = y) = (1 - \\pi_i) \\cdot f_\\Gamma(y \\mid \\mu_i,\\, \\phi), \\quad y &gt; 0\\]\nThe two components have separate linear predictors. The conditional intensity mean is:\n\\[\\log(\\mu_i) = \\mathbf{X}_i \\boldsymbol{\\beta} + \\mathbf{Z}_i \\mathbf{b}\\]\nwhere \\(\\mathbf{X}_i\\) contains the fixed meteorological predictors and \\(\\mathbf{Z}_i \\mathbf{b}\\) encodes the location-specific random slopes. The zero-inflation probability is:\n\\[\\text{logit}(\\pi_i) = \\mathbf{W}_i \\boldsymbol{\\gamma}\\]\nwhere \\(\\mathbf{W}_i\\) is a distinct predictor matrix for the hurdle component, allowing the drivers of occurrence to differ from those of intensity.",
    "crumbs": [
      "Predicting Australian Rainfall"
    ]
  },
  {
    "objectID": "index.html#report-structure",
    "href": "index.html#report-structure",
    "title": "Australian Rainfall Dynamics",
    "section": "Report Structure",
    "text": "Report Structure\n\n\n\nProject Structure and Content\n\n\nChapter\nContent\n\n\n\n\nIntroduction\nStatistical pathology of Australian rainfall and the failure modes of OLS.\n\n\nData Preparation\nTwo-stage hybrid imputation strategy for 42-48% missingness in key meteorological variables.\n\n\nExploratory Data Analysis\nZero-inflation, distributional properties, Markovian persistence, and the Rain Corner.\n\n\nFeature Engineering\nWind vectors, cyclical encoding, interaction terms, and temporal lag features.\n\n\nModelling\nProgressive ZIG model construction from null baseline through spatial mixed effects.\n\n\nModel Evaluation\nROC analysis, spatial random effects, DHARMa diagnostics, and autocorrelation testing.\n\n\nModel Selection\nDistributional family comparison, likelihood ratio tests, and Nakagawa $R^2$ decomposition.\n\n\nConclusion\nPrincipal findings, limitations, and deployment recommendations.\n\n\n\n\n\n\n\n\n\n\n\n\nNoteReproducibility\n\n\n\nThe computational environment is managed via librarian. All fitted models are pre-bundled in .RData format, allowing the report to render without re-running the full glmmTMB optimisations, which involve high-dimensional mixed-effects likelihoods and can be computationally intensive. Source code and data are available at the repository linked above.",
    "crumbs": [
      "Predicting Australian Rainfall"
    ]
  },
  {
    "objectID": "04-features.html",
    "href": "04-features.html",
    "title": "4  Feature Engineering",
    "section": "",
    "text": "4.1 From Raw Meteorological Signals to Predictive Inputs",
    "crumbs": [
      "Feature Engineering",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Feature Engineering</span>"
    ]
  },
  {
    "objectID": "04-features.html#from-raw-meteorological-signals-to-predictive-inputs",
    "href": "04-features.html#from-raw-meteorological-signals-to-predictive-inputs",
    "title": "4  Feature Engineering",
    "section": "",
    "text": "Chapter Context. This chapter documents the feature engineering pipeline that bridges the exploratory analysis and the final model. Each design decision traces directly to an empirical finding from the EDA: the features constructed here are not ad hoc transformations but targeted responses to identified distributional and structural properties of the data.",
    "crumbs": [
      "Feature Engineering",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Feature Engineering</span>"
    ]
  },
  {
    "objectID": "04-features.html#signal-extraction-via-moving-averages",
    "href": "04-features.html#signal-extraction-via-moving-averages",
    "title": "4  Feature Engineering",
    "section": "4.2 Signal Extraction via Moving Averages",
    "text": "4.2 Signal Extraction via Moving Averages\nDaily meteorological observations are inherently noisy. A single day’s rainfall measurement reflects both the underlying weather regime and a high-frequency stochastic component, the difference between a storm cell passing directly over a station versus five kilometres to its east. Before engineering predictive features from this signal, we must first assess whether smoothing can reduce this noise and, if so, at what cost.\nWe compute rolling means over 3-day and 7-day trailing windows for both rainfall and afternoon humidity. Right-alignment is enforced throughout, meaning the average at time \\(t\\) is computed from observations at \\(t\\), \\(t-1\\), …, \\(t-(k-1)\\). This is a necessary precaution against data leakage: any lookahead alignment would contaminate the training signal with future observations.\n\n\nShow the code\nma_data &lt;- df_final %&gt;%\n  group_by(location) %&gt;%\n  arrange(date) %&gt;%\n  mutate(\n    rainfall_ma3 = rollmean(rainfall, k = 3, fill = NA, align = \"right\"),\n    rainfall_ma7 = rollmean(rainfall, k = 7, fill = NA, align = \"right\"),\n    humidity_ma3 = rollmean(humidity3pm, k = 3, fill = NA, align = \"right\"),\n    humidity_ma7 = rollmean(humidity3pm, k = 7, fill = NA, align = \"right\")\n  ) %&gt;%\n  ungroup()\n\n\n\n4.2.1 Noise Reduction\n\n\nShow the code\np1_data &lt;- ma_data %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  select(rainfall, rainfall_ma3, rainfall_ma7) %&gt;%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\") %&gt;%\n  filter(!is.na(value)) %&gt;%\n  mutate(\n    metric = factor(\n      metric,\n      levels = c(\"rainfall\", \"rainfall_ma3\", \"rainfall_ma7\"),\n      labels = c(\"Raw Daily\", \"3-Day MA\", \"7-Day MA\")\n    )\n  )\n\nggplot(p1_data, aes(x = value, fill = metric, color = metric)) +\n  geom_density(alpha = 0.4, linewidth = 1) +\n  annotation_logticks(sides = \"b\", color = \"grey60\", linewidth = 0.3) +\n  scale_x_log10(\n    breaks = c(0.1, 0.5, 1, 5, 10, 50, 100),\n    labels = label_number(suffix = \" mm\"),\n    expand = c(0, 0)\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Raw Daily\" = \"#E63946\",\n      \"3-Day MA\" = \"#F77F00\",\n      \"7-Day MA\" = \"#06A77D\"\n    )\n  ) +\n  scale_color_manual(\n    values = c(\n      \"Raw Daily\" = \"#E63946\",\n      \"3-Day MA\" = \"#F77F00\",\n      \"7-Day MA\" = \"#06A77D\"\n    )\n  ) +\n  labs(\n    title = \"Signal Extraction: Moving Averages Filter High-Frequency Noise\",\n    subtitle = \"Raw rainfall (Red) exhibits high stochastic variance with extreme skew. The 7-Day Moving Average (Green)\\nacts as a low-pass filter, suppressing daily noise to reveal the central tendency of wet regimes.\",\n    x = \"Rainfall Intensity (Log Scale)\",\n    y = \"Density\",\n    caption = \"Data: Log-transformed daily rainfall recordings\",\n    fill = NULL,\n    color = NULL\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    legend.position = \"top\",\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_line(color = \"grey90\", size = 0.3),\n    panel.grid.major.y = element_line(color = \"grey90\", size = 0.3),\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(\n      color = \"grey30\",\n      size = 11,\n      margin = margin(b = 15)\n    ),\n    axis.text.x = element_text(margin = margin(t = 5))\n  )\n\n\n\n\n\n\n\n\nFigure 4.1: Signal Extraction: Moving Averages Filter High-Frequency Noise. The 7-Day Moving Average (Green) suppresses daily stochastic variance to reveal the central tendency of wet regimes.\n\n\n\n\n\n\n\nShow the code\nvariance_data &lt;- ma_data %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  summarise(\n    Raw = sd(rainfall, na.rm = TRUE),\n    `3-Day MA` = sd(rainfall_ma3, na.rm = TRUE),\n    `7-Day MA` = sd(rainfall_ma7, na.rm = TRUE)\n  ) %&gt;%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"sd\") %&gt;%\n  mutate(\n    metric = factor(metric, levels = c(\"Raw\", \"3-Day MA\", \"7-Day MA\")),\n    variance_reduction = (sd[1] - sd) / sd[1] * 100\n  )\n\nggplot(variance_data, aes(metric, sd, fill = metric)) +\n  geom_col(alpha = 0.8, width = 0.6) +\n  geom_text(\n    aes(label = sprintf(\"%.1f mm\\n(%.0f%% reduction)\", sd, variance_reduction)),\n    vjust = -0.3,\n    fontface = \"bold\",\n    size = 4.5\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Raw\" = \"#E63946\",\n      \"3-Day MA\" = \"#F77F00\",\n      \"7-Day MA\" = \"#06A77D\"\n    )\n  ) +\n  labs(\n    title = \"Variance Reduction by Moving Averages\",\n    subtitle = \"Standard deviation decreases as window increases\",\n    y = \"Standard Deviation (mm)\",\n    x = NULL\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", margin = margin(b = 10)),\n    legend.position = \"none\",\n    panel.grid.major.x = element_blank(),\n    axis.text.x = element_text(face = \"bold\", size = 12)\n  ) +\n  ylim(0, max(variance_data$sd) * 1.15)\n\n\n\n\n\n\n\n\nFigure 4.2: Variance Reduction by Window Size. Standard deviation falls substantially as the averaging window widens.\n\n\n\n\n\n\n\nShow the code\nridge_data &lt;- ma_data %&gt;%\n  filter(rainfall &gt; 0) %&gt;%\n  select(rainfall, rainfall_ma3, rainfall_ma7) %&gt;%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\") %&gt;%\n  filter(!is.na(value)) %&gt;%\n  mutate(\n    metric = factor(\n      metric,\n      levels = c(\"rainfall_ma7\", \"rainfall_ma3\", \"rainfall\"),\n      labels = c(\"7-Day MA\", \"3-Day MA\", \"Raw Daily\")\n    )\n  )\n\nggplot(ridge_data, aes(value, metric, fill = metric)) +\n  geom_density_ridges(\n    alpha = 0.7,\n    scale = 1.5,\n    quantile_lines = TRUE,\n    quantiles = 2\n  ) +\n  scale_x_log10(\n    breaks = c(1, 5, 10, 25, 50, 100),\n    labels = c(\"1\", \"5\", \"10\", \"25\", \"50\", \"100\")\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Raw Daily\" = \"#E63946\",\n      \"3-Day MA\" = \"#F77F00\",\n      \"7-Day MA\" = \"#06A77D\"\n    )\n  ) +\n  labs(\n    title = \"Distribution Tightening with Moving Averages\",\n    subtitle = \"Peaks become sharper and tails compress as window size increases\",\n    x = \"Rainfall (mm, log scale)\",\n    y = NULL\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", margin = margin(b = 15)),\n    legend.position = \"none\",\n    axis.text.y = element_text(face = \"bold\", size = 12),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank()\n  )\n\n\n\n\n\n\n\n\nFigure 4.3: Distribution Tightening with Moving Averages. Peaks sharpen and tails compress as the averaging window increases.\n\n\n\n\n\nThe density plots in Figure 4.1 make the smoothing effect immediately apparent. The raw daily distribution (pink) is severely right-skewed with a long tail reaching into the hundreds of millimetres, a consequence of the extreme kurtosis documented in the Chapter 3. The 3-day moving average (orange) begins to suppress this variance, and the 7-day average (green) produces a substantially more concentrated distribution whose peak is considerably higher and whose tails are dramatically shorter.\nQuantitatively (Figure 4.2), the standard deviation of rainfall intensity falls from 13.1 mm in the raw series to 5.8 mm under the 7-day average, a reduction of 56%. The ridgeline plot (Figure 4.3) confirms that this compression is not an artefact of the summary statistic: the entire shape of the distribution tightens, with each additional day of averaging producing a distribution that is more peaked and less diffuse. The 7-day average can therefore be interpreted as a measure of the “weekly wetness regime”.A smoothed characterisation of whether the preceding week has been generally wet or generally dry rather than the unpredictability of any single day’s precipitation.\n\n\n4.2.2 Multicollinearity Trade-off\n\n\nShow the code\ncor_data &lt;- ma_data %&gt;%\n  select(\n    rainfall,\n    rainfall_ma3,\n    rainfall_ma7,\n    humidity3pm,\n    humidity_ma3,\n    humidity_ma7\n  ) %&gt;%\n  cor(use = \"complete.obs\", method = \"spearman\") %&gt;%\n  as.data.frame() %&gt;%\n  rownames_to_column(\"var1\") %&gt;%\n  pivot_longer(-var1, names_to = \"var2\", values_to = \"correlation\") %&gt;%\n  mutate(\n    var1 = factor(\n      var1,\n      levels = c(\n        \"rainfall\",\n        \"rainfall_ma3\",\n        \"rainfall_ma7\",\n        \"humidity3pm\",\n        \"humidity_ma3\",\n        \"humidity_ma7\"\n      )\n    ),\n    var2 = factor(\n      var2,\n      levels = c(\n        \"rainfall\",\n        \"rainfall_ma3\",\n        \"rainfall_ma7\",\n        \"humidity3pm\",\n        \"humidity_ma3\",\n        \"humidity_ma7\"\n      )\n    )\n  )\n\nggplot(cor_data, aes(var2, var1, fill = correlation)) +\n  geom_tile(color = \"white\", linewidth = 1) +\n  geom_text(\n    aes(label = sprintf(\"%.2f\", correlation)),\n    fontface = \"bold\",\n    size = 3.5\n  ) +\n  scale_fill_gradient2(\n    low = \"#0072B2\",\n    mid = \"white\",\n    high = \"#D55E00\",\n    midpoint = 0,\n    limits = c(-1, 1),\n    name = \"Correlation\"\n  ) +\n  labs(\n    title = \"Feature Correlations: Raw vs Moving Averages\",\n    subtitle = \"MAs are highly correlated with each other (potential multicollinearity)\",\n    x = NULL,\n    y = NULL\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(color = \"grey40\", margin = margin(b = 10)),\n    axis.text.x = element_text(angle = 45, hjust = 1, face = \"bold\"),\n    axis.text.y = element_text(face = \"bold\"),\n    panel.grid = element_blank()\n  )\n\n\n\n\n\n\n\n\nFigure 4.4: Feature Correlations: Raw vs Moving Averages. High correlations between MA features warn of multicollinearity risks for linear model families.\n\n\n\n\n\nThe noise-reduction benefit of moving averages comes at a cost. As shown in Figure 4.4, the 3-day and 7-day humidity moving averages share a Spearman correlation of 0.89, and the equivalent rainfall moving averages are similarly collinear with each other and with the raw series. Including multiple moving average windows alongside their source variables in the same linear model would produce a near-singular design matrix, inflating coefficient standard errors and making the model numerically unstable.\nThis presents a choice between responsiveness and stability. The 3-day average reacts more quickly to changing conditions but retains more of the day-to-day variability. The 7-day average is more stable but slower to reflect recent changes in the weather regime. For linear model families such as logistic regression, only one window can be safely retained per variable; including both is not viable. For tree-based models like Random Forest and Gradient Boosting, this constraint does not apply, since these methods select among correlated features at each split rather than inverting the full covariance matrix. The moving average selection strategy therefore depends on the model family, a consideration that informs the variable selection carried out in the subsequent modelling chapter.",
    "crumbs": [
      "Feature Engineering",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Feature Engineering</span>"
    ]
  },
  {
    "objectID": "04-features.html#feature-engineering-pipeline",
    "href": "04-features.html#feature-engineering-pipeline",
    "title": "4  Feature Engineering",
    "section": "4.3 Feature Engineering Pipeline",
    "text": "4.3 Feature Engineering Pipeline\nThe following pipeline implements the complete set of features motivated by the EDA. Each transformation is annotated to its originating empirical finding.\n\n\nShow the code\ncompass_lookup &lt;- c(\n  \"N\" = 0,\n  \"NNE\" = 22.5,\n  \"NE\" = 45,\n  \"ENE\" = 67.5,\n  \"E\" = 90,\n  \"ESE\" = 112.5,\n  \"SE\" = 135,\n  \"SSE\" = 157.5,\n  \"S\" = 180,\n  \"SSW\" = 202.5,\n  \"SW\" = 225,\n  \"WSW\" = 247.5,\n  \"W\" = 270,\n  \"WNW\" = 292.5,\n  \"NW\" = 315,\n  \"NNW\" = 337.5\n)\n\ndf_final &lt;- df_final %&gt;%\n  group_by(location) %&gt;%\n  arrange(date) %&gt;%\n  mutate(\n    # Lagging MA by 1 day ensures we predict 'Today' using only 'Yesterday's'\n    # trends to prevent data leakage\n    rainfall_ma7 = lag(\n      rollmean(rainfall, k = 7, fill = NA, align = \"right\"),\n      n = 1\n    ),\n    humidity_ma7 = lag(\n      rollmean(humidity3pm, k = 7, fill = NA, align = \"right\"),\n      1\n    ),\n\n    # Dry Spell Calculation\n    rain_event_id = cumsum(lag(rainfall, 1) &gt; 0),\n    days_since_rain = row_number() - match(rain_event_id, rain_event_id),\n\n    # Markov Chain State\n    rain_yesterday = lag(rain_today, n = 1)\n  ) %&gt;%\n  ungroup() %&gt;%\n  filter(!is.na(rain_yesterday), !is.na(rainfall_ma7)) %&gt;%\n  select(-rain_event_id) %&gt;%\n  mutate(\n    # Cyclical Time Encoding\n    day_of_year = yday(date),\n    day_sin = sin(2 * pi * day_of_year / 365),\n    day_cos = cos(2 * pi * day_of_year / 365),\n\n    # Interaction Terms (The \"Rain Corner\")\n    sunshine = as.numeric(scale(sunshine, center = TRUE, scale = FALSE)),\n    humidity3pm = as.numeric(scale(humidity3pm, center = TRUE, scale = FALSE)),\n    sun_humid_interaction = as.numeric(sunshine * humidity3pm),\n\n    # Meteorological Indices\n    pressure_change = pressure3pm - pressure9am,\n    dewpoint_9am = temp9am - ((100 - humidity9am) / 5),\n    dewpoint_3pm = temp3pm - ((100 - humidity3pm) / 5),\n    dewpoint_change = dewpoint_3pm - dewpoint_9am,\n    moisture_index = humidity3pm * (1 - sunshine / 15),\n    instability_index = (1020 - pressure3pm) * humidity3pm / 100,\n    cloud_development = pmax(0, cloud3pm - cloud9am),\n\n    # Circular Wind Vector Decomposition\n    gust_rad = compass_lookup[wind_gust_dir] * pi / 180,\n    gust_V_NS = wind_gust_speed * cos(gust_rad),\n    gust_U_EW = wind_gust_speed * sin(gust_rad),\n    wind9am_rad = compass_lookup[wind_dir9am] * pi / 180,\n    wind9am_V_NS = wind_speed9am * cos(wind9am_rad),\n    wind9am_U_EW = wind_speed9am * sin(wind9am_rad)\n  ) %&gt;%\n  relocate(rain_today, date, location) %&gt;%\n  relocate(rain_yesterday, days_since_rain, .after = location) %&gt;%\n  relocate(ends_with(\"_ma7\"), .after = days_since_rain) %&gt;%\n  relocate(day_sin, day_cos, .after = date)\n\n\nThe pipeline is organised into four conceptually distinct transformations, each addressing a specific structural property identified in the EDA.\n\n4.3.1 Cyclical Encoding of Seasonality\nThe seasonal analysis established that rainfall frequency and intensity follow a smooth annual cycle: summer events are rarer but more intense, winter events are more frequent but lighter, and the transition months connect these poles continuously. Treating month as a standard integer (1 through 12) would incorrectly imply that January and December are maximally distant on the number line, when in reality they are climatologically adjacent. Treating it as an unordered factor imposes no such adjacency constraint but discards ordinal information entirely.\nThe appropriate solution is to represent the annual cycle as a point on the unit circle, decomposed into its sine and cosine components:\n\\[\\text{day\\_sin} = \\sin\\!\\left(\\frac{2\\pi \\cdot \\text{day\\_of\\_year}}{365}\\right), \\quad \\text{day\\_cos} = \\cos\\!\\left(\\frac{2\\pi \\cdot \\text{day\\_of\\_year}}{365}\\right)\\]\nTogether, these two features encode any day of the year as a unique coordinate on the unit circle. The distance between any two days in this space reflects their true circular proximity: the December-to-January transition corresponds to a small arc, not a large jump. The model can learn smooth seasonal effects directly from the geometry of this representation.\n\n\n4.3.2 Temporal Persistence Features\nThe Markov Chain analysis (Section 3.5.2) demonstrated that the previous day’s rain state carries a moderate but meaningful signal (\\(V \\approx 0.31\\)), and the dry spell analysis showed that the probability of rain decays in a non-linear pattern as dry spells lengthen. Three features capture these dynamics.\nrain_yesterday is a direct binary indicator of the previous day’s state, encoding the first-order Markov transition directly as a predictor. days_since_rain counts the number of consecutive dry days preceding the current observation, capturing the progressive stabilisation of dry conditions that the logistic regression and spline analysis identified. rainfall_ma7 and humidity_ma7 provide a smoothed weekly context for both the rainfall and moisture signals, lagged by one additional day beyond the rolling window to ensure that no same-day information is included when predicting today’s outcome.\nThe lagging step deserves emphasis. Without it, the 7-day moving average at time \\(t\\) includes the observation at time \\(t\\) itself, meaning a model trained on this feature would have access to the value it is trying to predict. This form of data leakage produces artificially optimistic training metrics that do not generalise to deployment, where future observations are unavailable by definition.\n\n\n4.3.3 Physical Interaction and Derived Indices\nThe bivariate density analysis (Section 3.8) identified a qualitative difference in the joint distribution of humidity and sunshine between rainy and dry days: rain occurs almost exclusively when afternoon humidity is high and sunshine hours are low simultaneously, the “Rain Corner” phenomenon. An additive model cannot represent this conditional structure; a multiplicative interaction term is required.\nPrior to computing the interaction, both sunshine and humidity3pm are mean-centred (their grand means are subtracted). This is not merely a cosmetic step. When an interaction term is formed from un-centred variables, the resulting product is algebraically correlated with both main effects, inflating the VIF of all three terms and making their individual coefficients difficult to interpret. Centring removes this artificial correlation: the main effects then represent the effect of each variable at the average level of the other, and the interaction term represents the additional effect of their joint deviation. This is confirmed empirically in the VIF diagnostics in Section 3.\nBeyond the interaction term, five derived meteorological indices are constructed from physically motivated combinations of the available variables. The dewpoint temperatures at 9:00 AM and 3:00 PM computed from the Magnus approximation \\(T_d \\approx T - \\frac{100 - RH}{5}\\) represent the temperature at which the air would become saturated if cooled at constant pressure. The change in dewpoint across the day (dewpoint_change) measures whether the atmosphere is gaining or losing moisture over the course of the day, a signal not directly recoverable from temperature or humidity alone. The moisture_index encodes the combined effect of high humidity and limited solar exposure. The instability_index combines pressure deficit from the standard 1020 hPa baseline with humidity, approximating the atmospheric conditions that favour convective development. cloud_development captures upward cloud formation during the day, which the pressure analysis identified as a meaningful precursor to precipitation.\n\n\n4.3.4 Circular Wind Vector Decomposition\nWind direction is a circular variable: 360 \\(^\\circ\\) and 0 \\(^\\circ\\) represent the same direction (due North), yet a naive numeric encoding would treat them as maximally distant. This misrepresentation is particularly consequential for wind because the directional origin of an air mass carries meaningful physical content, moisture-laden northerly flows behave very differently from dry southerly flows in the Australian context.\nThe standard solution is to decompose each directional reading into orthogonal Cartesian components by projecting the wind vector onto the north-south and east-west axes:\n\\[U_{EW} = v \\cdot \\sin(\\theta), \\quad V_{NS} = v \\cdot \\cos(\\theta)\\]\nwhere \\(v\\) is wind speed (in km/h) and \\(\\theta\\) is the compass bearing in radians. The resulting U and V components are continuous and interpretable: a purely northerly wind of 20 km/h produces \\(V_{NS} = 20\\), \\(U_{EW} = 0\\); a purely easterly wind of the same speed produces \\(V_{NS} = 0\\), \\(U_{EW} = 20\\). This transformation is applied to both the peak gust and the 9:00 AM wind observations, yielding four wind component features in total.",
    "crumbs": [
      "Feature Engineering",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Feature Engineering</span>"
    ]
  },
  {
    "objectID": "04-features.html#multicollinearity-diagnostics",
    "href": "04-features.html#multicollinearity-diagnostics",
    "title": "4  Feature Engineering",
    "section": "4.4 Multicollinearity Diagnostics",
    "text": "4.4 Multicollinearity Diagnostics\n\n\nShow the code\nwrite_csv(df_final, \"data/df_engineered.csv\")\n\ndf_wo_location &lt;- select_model_features(df_final, keep_location = FALSE)\n\nvif_results &lt;- mc_check(df_wo_location)\n\nvif_results %&gt;%\n  as_tibble() %&gt;%\n  arrange(desc(VIF)) %&gt;%\n  kable(\n    caption = \"Variance Inflation Factor (VIF) for Selected Predictors\",\n    digits = 3\n  ) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"), full_width = FALSE)\n\n\n\nVariance Inflation Factor (VIF) for Selected Predictors\n\n\nTerm\nVIF\nVIF_CI_low\nVIF_CI_high\nSE_factor\nTolerance\nTolerance_CI_low\nTolerance_CI_high\n\n\n\n\nhumidity3pm\n4.728\n4.684\n4.772\n2.174\n0.211\n0.210\n0.213\n\n\nhumidity9am\n2.589\n2.567\n2.611\n1.609\n0.386\n0.383\n0.390\n\n\nhumidity_ma7\n2.334\n2.315\n2.354\n1.528\n0.428\n0.425\n0.432\n\n\ndewpoint_9am\n2.150\n2.133\n2.167\n1.466\n0.465\n0.461\n0.469\n\n\ninstability_index\n2.076\n2.060\n2.092\n1.441\n0.482\n0.478\n0.486\n\n\nsunshine\n1.918\n1.904\n1.933\n1.385\n0.521\n0.517\n0.525\n\n\nday_cos\n1.868\n1.854\n1.882\n1.367\n0.535\n0.531\n0.539\n\n\nevaporation\n1.786\n1.773\n1.800\n1.336\n0.560\n0.556\n0.564\n\n\ndewpoint_change\n1.762\n1.749\n1.775\n1.327\n0.567\n0.563\n0.572\n\n\nwind9am_U_EW\n1.642\n1.630\n1.654\n1.281\n0.609\n0.605\n0.613\n\n\nwind9am_V_NS\n1.639\n1.627\n1.651\n1.280\n0.610\n0.606\n0.614\n\n\ngust_V_NS\n1.629\n1.618\n1.641\n1.277\n0.614\n0.609\n0.618\n\n\ngust_U_EW\n1.614\n1.602\n1.626\n1.270\n0.620\n0.615\n0.624\n\n\nrainfall_ma7\n1.327\n1.318\n1.336\n1.152\n0.754\n0.749\n0.758\n\n\nsun_humid_interaction\n1.185\n1.178\n1.192\n1.089\n0.844\n0.839\n0.849\n\n\nrain_yesterday\n1.183\n1.176\n1.190\n1.088\n0.845\n0.840\n0.850\n\n\nday_sin\n1.161\n1.154\n1.168\n1.077\n0.862\n0.856\n0.867\n\n\npressure_change\n1.110\n1.104\n1.117\n1.054\n0.901\n0.896\n0.906\n\n\ncloud_development\n1.032\n1.026\n1.038\n1.016\n0.969\n0.964\n0.974\n\n\ndays_since_rain\n1.004\n1.001\n1.015\n1.002\n0.996\n0.986\n0.999\n\n\n\n\n\nShow the code\ndf_scaled &lt;- df_wo_location %&gt;%\n  scale_data()\n\nwrite_csv(df_scaled, \"data/df_scaled.csv\")\n\n\nFeature engineering that introduces interaction terms, composite indices, and temporal aggregates necessarily creates new correlational structure in the design matrix. After constructing the full feature set, it is therefore essential to verify that no predictor has become so collinear with the others that its coefficient in a linear model would be effectively unidentifiable. We use the Variance Inflation Factor (VIF) for this diagnosis. The VIF for a given predictor quantifies how much its coefficient variance is inflated relative to what it would be in an orthogonal design: a VIF of \\(k\\) indicates that the standard error of that coefficient is \\(\\sqrt{k}\\) times larger than it would be if the predictor were uncorrelated with all others. Values above 10 are conventionally treated as indicating severe collinearity requiring remediation.\nCyclical and wind components. The day_sin, day_cos, gust_V_NS, and gust_U_EW features all show VIF values well below 3. This confirms that the decomposition strategies, sine/cosine for the annual cycle and U/V projection for wind direction, successfully converted circular variables into continuous representations without introducing redundancy. Each component carries information that is approximately orthogonal to its pair.\nInteraction stability. The sun_humid_interaction term has a VIF of 1.188, which is exceptionally low for a multiplicative interaction. Without mean-centring the constituent variables before multiplication, interaction terms routinely exhibit VIFs above 10 due to their algebraic overlap with the main effects. The observed value of 1.188 provides empirical confirmation that centring eliminated this artificial correlation, and that the interaction term is capturing a genuinely distinct dimension of the feature space, the joint “Rain Corner” structure identified in the EDA.\nElevated collinearity in humidity. The highest observed VIF is for humidity3pm at approximately 4.832. This is expected: humidity participates structurally in three of the derived features (moisture_index, instability_index, and sun_humid_interaction), and its 7-day moving average is also present in the feature set. A VIF of 5 lies below the conventional threshold of 10 for severe concern and is consistent with what the literature describes as moderate collinearity. The decision to retain humidity3pm despite this inflation is deliberate: it is the single strongest individual predictor of rainfall in the dataset (Spearman \\(r = 0.44\\), as established in the Chapter 3), and removing it in favour of its derived aggregates would sacrifice the direct same-day atmospheric moisture signal for the sake of a marginal improvement in collinearity. For tree-based models, this trade-off does not arise, since these methods are not sensitive to multicollinearity by design.\nOverall assessment. The full engineered feature set is numerically stable for use in linear model families. No VIF exceeds the critical threshold of 10, and the majority of features show values below 3. The pipeline has successfully converted the raw meteorological signals into a representation that is both physically interpretable and statistically well-conditioned for the modelling stage.",
    "crumbs": [
      "Feature Engineering",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Feature Engineering</span>"
    ]
  }
]