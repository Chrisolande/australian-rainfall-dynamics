# Feature Engineering {#sec-feature-eng}
## From Raw Meteorological Signals to Predictive Inputs

---

> **Chapter Context.** This chapter documents the feature engineering pipeline that bridges the exploratory analysis and the final model. Each design decision traces directly to an empirical finding from the EDA: the features constructed here are not ad hoc transformations but targeted responses to identified distributional and structural properties of the data.

---

## Signal Extraction via Moving Averages

Daily meteorological observations are inherently noisy. A single day's rainfall measurement reflects both the underlying weather regime and a high-frequency stochastic component, the difference between a storm cell passing directly over a station versus five kilometres to its east. Before engineering predictive features from this signal, we must first assess whether smoothing can reduce this noise and, if so, at what cost.

We compute rolling means over 3-day and 7-day trailing windows for both rainfall and afternoon humidity. Right-alignment is enforced throughout, meaning the average at time $t$ is computed from observations at $t$, $t-1$, ..., $t-(k-1)$. This is a necessary precaution against data leakage: any lookahead alignment would contaminate the training signal with future observations.

```{r}
#| label: setup-features
#| include: false

librarian::shelf(
  tidyverse,
  zoo,
  ggridges,
  scales,
  kableExtra,
  performance,
  here
)


df_final <- read_csv("data/df_final.csv")
source(here::here("utils.R"))
```


```{r}
#| label: ma-feature-engineering
#| echo: true
#| message: false

ma_data <- df_final %>%
  group_by(location) %>%
  arrange(date) %>%
  mutate(
    rainfall_ma3 = rollmean(rainfall, k = 3, fill = NA, align = "right"),
    rainfall_ma7 = rollmean(rainfall, k = 7, fill = NA, align = "right"),
    humidity_ma3 = rollmean(humidity3pm, k = 3, fill = NA, align = "right"),
    humidity_ma7 = rollmean(humidity3pm, k = 7, fill = NA, align = "right")
  ) %>%
  ungroup()
```

### Noise Reduction

```{r}
#| label: fig-signal-extraction
#| fig-cap: "Signal Extraction: Moving Averages Filter High-Frequency Noise. The 7-Day Moving Average (Green) suppresses daily stochastic variance to reveal the central tendency of wet regimes."
#| fig-width: 10
#| fig-height: 8
#| echo: true
#| warning: false

p1_data <- ma_data %>%
  filter(rainfall > 0) %>%
  select(rainfall, rainfall_ma3, rainfall_ma7) %>%
  pivot_longer(everything(), names_to = "metric", values_to = "value") %>%
  filter(!is.na(value)) %>%
  mutate(
    metric = factor(
      metric,
      levels = c("rainfall", "rainfall_ma3", "rainfall_ma7"),
      labels = c("Raw Daily", "3-Day MA", "7-Day MA")
    )
  )

ggplot(p1_data, aes(x = value, fill = metric, color = metric)) +
  geom_density(alpha = 0.4, linewidth = 1) +
  annotation_logticks(sides = "b", color = "grey60", linewidth = 0.3) +
  scale_x_log10(
    breaks = c(0.1, 0.5, 1, 5, 10, 50, 100),
    labels = label_number(suffix = " mm"),
    expand = c(0, 0)
  ) +
  scale_fill_manual(
    values = c(
      "Raw Daily" = "#E63946",
      "3-Day MA" = "#F77F00",
      "7-Day MA" = "#06A77D"
    )
  ) +
  scale_color_manual(
    values = c(
      "Raw Daily" = "#E63946",
      "3-Day MA" = "#F77F00",
      "7-Day MA" = "#06A77D"
    )
  ) +
  labs(
    title = "Signal Extraction: Moving Averages Filter High-Frequency Noise",
    subtitle = "Raw rainfall (Red) exhibits high stochastic variance with extreme skew. The 7-Day Moving Average (Green)\nacts as a low-pass filter, suppressing daily noise to reveal the central tendency of wet regimes.",
    x = "Rainfall Intensity (Log Scale)",
    y = "Density",
    caption = "Data: Log-transformed daily rainfall recordings",
    fill = NULL,
    color = NULL
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(color = "grey90", size = 0.3),
    panel.grid.major.y = element_line(color = "grey90", size = 0.3),
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(
      color = "grey30",
      size = 11,
      margin = margin(b = 15)
    ),
    axis.text.x = element_text(margin = margin(t = 5))
  )
```

```{r}
#| label: fig-variance-reduction
#| fig-cap: "Variance Reduction by Window Size. Standard deviation falls substantially as the averaging window widens."
#| fig-width: 8
#| fig-height: 6
#| echo: true
#| warning: false

variance_data <- ma_data %>%
  filter(rainfall > 0) %>%
  summarise(
    Raw = sd(rainfall, na.rm = TRUE),
    `3-Day MA` = sd(rainfall_ma3, na.rm = TRUE),
    `7-Day MA` = sd(rainfall_ma7, na.rm = TRUE)
  ) %>%
  pivot_longer(everything(), names_to = "metric", values_to = "sd") %>%
  mutate(
    metric = factor(metric, levels = c("Raw", "3-Day MA", "7-Day MA")),
    variance_reduction = (sd[1] - sd) / sd[1] * 100
  )

ggplot(variance_data, aes(metric, sd, fill = metric)) +
  geom_col(alpha = 0.8, width = 0.6) +
  geom_text(
    aes(label = sprintf("%.1f mm\n(%.0f%% reduction)", sd, variance_reduction)),
    vjust = -0.3,
    fontface = "bold",
    size = 4.5
  ) +
  scale_fill_manual(
    values = c(
      "Raw" = "#E63946",
      "3-Day MA" = "#F77F00",
      "7-Day MA" = "#06A77D"
    )
  ) +
  labs(
    title = "Variance Reduction by Moving Averages",
    subtitle = "Standard deviation decreases as window increases",
    y = "Standard Deviation (mm)",
    x = NULL
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(color = "grey40", margin = margin(b = 10)),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    axis.text.x = element_text(face = "bold", size = 12)
  ) +
  ylim(0, max(variance_data$sd) * 1.15)
```

```{r}
#| label: fig-ma-ridgeline
#| fig-cap: "Distribution Tightening with Moving Averages. Peaks sharpen and tails compress as the averaging window increases."
#| fig-width: 9
#| fig-height: 7
#| echo: true
#| warning: false

ridge_data <- ma_data %>%
  filter(rainfall > 0) %>%
  select(rainfall, rainfall_ma3, rainfall_ma7) %>%
  pivot_longer(everything(), names_to = "metric", values_to = "value") %>%
  filter(!is.na(value)) %>%
  mutate(
    metric = factor(
      metric,
      levels = c("rainfall_ma7", "rainfall_ma3", "rainfall"),
      labels = c("7-Day MA", "3-Day MA", "Raw Daily")
    )
  )

ggplot(ridge_data, aes(value, metric, fill = metric)) +
  geom_density_ridges(
    alpha = 0.7,
    scale = 1.5,
    quantile_lines = TRUE,
    quantiles = 2
  ) +
  scale_x_log10(
    breaks = c(1, 5, 10, 25, 50, 100),
    labels = c("1", "5", "10", "25", "50", "100")
  ) +
  scale_fill_manual(
    values = c(
      "Raw Daily" = "#E63946",
      "3-Day MA" = "#F77F00",
      "7-Day MA" = "#06A77D"
    )
  ) +
  labs(
    title = "Distribution Tightening with Moving Averages",
    subtitle = "Peaks become sharper and tails compress as window size increases",
    x = "Rainfall (mm, log scale)",
    y = NULL
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(color = "grey40", margin = margin(b = 15)),
    legend.position = "none",
    axis.text.y = element_text(face = "bold", size = 12),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  )
```

The density plots in @fig-signal-extraction make the smoothing effect immediately apparent. The raw daily distribution (pink) is severely right-skewed with a long tail reaching into the hundreds of millimetres, a consequence of the extreme kurtosis documented in the @sec-eda. The 3-day moving average (orange) begins to suppress this variance, and the 7-day average (green) produces a substantially more concentrated distribution whose peak is considerably higher and whose tails are dramatically shorter.

Quantitatively (@fig-variance-reduction), the standard deviation of rainfall intensity falls from 13.1 mm in the raw series to 5.8 mm under the 7-day average, a reduction of 56%. The ridgeline plot (@fig-ma-ridgeline) confirms that this compression is not an artefact of the summary statistic: the entire shape of the distribution tightens, with each additional day of averaging producing a distribution that is more peaked and less diffuse. The 7-day average can therefore be interpreted as a measure of the "weekly wetness regime".A smoothed characterisation of whether the preceding week has been generally wet or generally dry rather than the unpredictability of any single day's precipitation.

### Multicollinearity Trade-off

```{r}
#| label: fig-ma-correlation
#| fig-cap: "Feature Correlations: Raw vs Moving Averages. High correlations between MA features warn of multicollinearity risks for linear model families."
#| fig-width: 8
#| fig-height: 8
#| echo: true
#| warning: false

cor_data <- ma_data %>%
  select(
    rainfall,
    rainfall_ma3,
    rainfall_ma7,
    humidity3pm,
    humidity_ma3,
    humidity_ma7
  ) %>%
  cor(use = "complete.obs", method = "spearman") %>%
  as.data.frame() %>%
  rownames_to_column("var1") %>%
  pivot_longer(-var1, names_to = "var2", values_to = "correlation") %>%
  mutate(
    var1 = factor(
      var1,
      levels = c(
        "rainfall",
        "rainfall_ma3",
        "rainfall_ma7",
        "humidity3pm",
        "humidity_ma3",
        "humidity_ma7"
      )
    ),
    var2 = factor(
      var2,
      levels = c(
        "rainfall",
        "rainfall_ma3",
        "rainfall_ma7",
        "humidity3pm",
        "humidity_ma3",
        "humidity_ma7"
      )
    )
  )

ggplot(cor_data, aes(var2, var1, fill = correlation)) +
  geom_tile(color = "white", linewidth = 1) +
  geom_text(
    aes(label = sprintf("%.2f", correlation)),
    fontface = "bold",
    size = 3.5
  ) +
  scale_fill_gradient2(
    low = "#0072B2",
    mid = "white",
    high = "#D55E00",
    midpoint = 0,
    limits = c(-1, 1),
    name = "Correlation"
  ) +
  labs(
    title = "Feature Correlations: Raw vs Moving Averages",
    subtitle = "MAs are highly correlated with each other (potential multicollinearity)",
    x = NULL,
    y = NULL
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(color = "grey40", margin = margin(b = 10)),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    panel.grid = element_blank()
  )
```

The noise-reduction benefit of moving averages comes at a cost. As shown in @fig-ma-correlation, the 3-day and 7-day humidity moving averages share a Spearman correlation of 0.89, and the equivalent rainfall moving averages are similarly collinear with each other and with the raw series. Including multiple moving average windows alongside their source variables in the same linear model would produce a near-singular design matrix, inflating coefficient standard errors and making the model numerically unstable.

This presents a choice between responsiveness and stability. The 3-day average reacts more quickly to changing conditions but retains more of the day-to-day variability. The 7-day average is more stable but slower to reflect recent changes in the weather regime. For linear model families such as logistic regression, only one window can be safely retained per variable; including both is not viable. For tree-based models like Random Forest and Gradient Boosting, this constraint does not apply, since these methods select among correlated features at each split rather than inverting the full covariance matrix. The moving average selection strategy therefore depends on the model family, a consideration that informs the variable selection carried out in the subsequent modelling chapter.

---

## Feature Engineering Pipeline

The following pipeline implements the complete set of features motivated by the EDA. Each transformation is annotated to its originating empirical finding.

```{r}
#| label: feature-engineering
#| echo: true
#| message: false
#| warning: false

compass_lookup <- c(
  "N" = 0,
  "NNE" = 22.5,
  "NE" = 45,
  "ENE" = 67.5,
  "E" = 90,
  "ESE" = 112.5,
  "SE" = 135,
  "SSE" = 157.5,
  "S" = 180,
  "SSW" = 202.5,
  "SW" = 225,
  "WSW" = 247.5,
  "W" = 270,
  "WNW" = 292.5,
  "NW" = 315,
  "NNW" = 337.5
)

df_final <- df_final %>%
  group_by(location) %>%
  arrange(date) %>%
  mutate(
    # Lagging MA by 1 day ensures we predict 'Today' using only 'Yesterday's'
    # trends to prevent data leakage
    rainfall_ma7 = lag(
      rollmean(rainfall, k = 7, fill = NA, align = "right"),
      n = 1
    ),
    humidity_ma7 = lag(
      rollmean(humidity3pm, k = 7, fill = NA, align = "right"),
      1
    ),

    # Dry Spell Calculation
    rain_event_id = cumsum(lag(rainfall, 1) > 0),
    days_since_rain = row_number() - match(rain_event_id, rain_event_id),

    # Markov Chain State
    rain_yesterday = lag(rain_today, n = 1)
  ) %>%
  ungroup() %>%
  filter(!is.na(rain_yesterday), !is.na(rainfall_ma7)) %>%
  select(-rain_event_id) %>%
  mutate(
    # Cyclical Time Encoding
    day_of_year = yday(date),
    day_sin = sin(2 * pi * day_of_year / 365),
    day_cos = cos(2 * pi * day_of_year / 365),

    # Interaction Terms (The "Rain Corner")
    sunshine = as.numeric(scale(sunshine, center = TRUE, scale = FALSE)),
    humidity3pm = as.numeric(scale(humidity3pm, center = TRUE, scale = FALSE)),
    sun_humid_interaction = as.numeric(sunshine * humidity3pm),

    # Meteorological Indices
    pressure_change = pressure3pm - pressure9am,
    dewpoint_9am = temp9am - ((100 - humidity9am) / 5),
    dewpoint_3pm = temp3pm - ((100 - humidity3pm) / 5),
    dewpoint_change = dewpoint_3pm - dewpoint_9am,
    moisture_index = humidity3pm * (1 - sunshine / 15),
    instability_index = (1020 - pressure3pm) * humidity3pm / 100,
    cloud_development = pmax(0, cloud3pm - cloud9am),

    # Circular Wind Vector Decomposition
    gust_rad = compass_lookup[wind_gust_dir] * pi / 180,
    gust_V_NS = wind_gust_speed * cos(gust_rad),
    gust_U_EW = wind_gust_speed * sin(gust_rad),
    wind9am_rad = compass_lookup[wind_dir9am] * pi / 180,
    wind9am_V_NS = wind_speed9am * cos(wind9am_rad),
    wind9am_U_EW = wind_speed9am * sin(wind9am_rad)
  ) %>%
  relocate(rain_today, date, location) %>%
  relocate(rain_yesterday, days_since_rain, .after = location) %>%
  relocate(ends_with("_ma7"), .after = days_since_rain) %>%
  relocate(day_sin, day_cos, .after = date)
```

The pipeline is organised into four conceptually distinct transformations, each addressing a specific structural property identified in the EDA.

### Cyclical Encoding of Seasonality

The seasonal analysis established that rainfall frequency and intensity follow a smooth annual cycle: summer events are rarer but more intense, winter events are more frequent but lighter, and the transition months connect these poles continuously. Treating month as a standard integer (1 through 12) would incorrectly imply that January and December are maximally distant on the number line, when in reality they are climatologically adjacent. Treating it as an unordered factor imposes no such adjacency constraint but discards ordinal information entirely.

The appropriate solution is to represent the annual cycle as a point on the unit circle, decomposed into its sine and cosine components:

$$\text{day\_sin} = \sin\!\left(\frac{2\pi \cdot \text{day\_of\_year}}{365}\right), \quad \text{day\_cos} = \cos\!\left(\frac{2\pi \cdot \text{day\_of\_year}}{365}\right)$$

Together, these two features encode any day of the year as a unique coordinate on the unit circle. The distance between any two days in this space reflects their true circular proximity: the December-to-January transition corresponds to a small arc, not a large jump. The model can learn smooth seasonal effects directly from the geometry of this representation.

### Temporal Persistence Features

The Markov Chain analysis (@sec-markov) demonstrated that the previous day's rain state carries a moderate but meaningful signal ($V \approx 0.31$), and the dry spell analysis showed that the probability of rain decays in a non-linear pattern as dry spells lengthen. Three features capture these dynamics.

`rain_yesterday` is a direct binary indicator of the previous day's state, encoding the first-order Markov transition directly as a predictor. `days_since_rain` counts the number of consecutive dry days preceding the current observation, capturing the progressive stabilisation of dry conditions that the logistic regression and spline analysis identified. `rainfall_ma7` and `humidity_ma7` provide a smoothed weekly context for both the rainfall and moisture signals, lagged by one additional day beyond the rolling window to ensure that no same-day information is included when predicting today's outcome.

The lagging step deserves emphasis. Without it, the 7-day moving average at time $t$ includes the observation at time $t$ itself, meaning a model trained on this feature would have access to the value it is trying to predict. This form of data leakage produces artificially optimistic training metrics that do not generalise to deployment, where future observations are unavailable by definition.

### Physical Interaction and Derived Indices

The bivariate density analysis (@sec-bivariate-density) identified a qualitative difference in the joint distribution of humidity and sunshine between rainy and dry days: rain occurs almost exclusively when afternoon humidity is high and sunshine hours are low simultaneously, the "Rain Corner" phenomenon. An additive model cannot represent this conditional structure; a multiplicative interaction term is required.

Prior to computing the interaction, both `sunshine` and `humidity3pm` are mean-centred (their grand means are subtracted). This is not merely a cosmetic step. When an interaction term is formed from un-centred variables, the resulting product is algebraically correlated with both main effects, inflating the VIF of all three terms and making their individual coefficients difficult to interpret. Centring removes this artificial correlation: the main effects then represent the effect of each variable at the average level of the other, and the interaction term represents the additional effect of their joint deviation. This is confirmed empirically in the VIF diagnostics in Section 3.

Beyond the interaction term, five derived meteorological indices are constructed from physically motivated combinations of the available variables. The dewpoint temperatures at 9:00 AM and 3:00 PM computed from the Magnus approximation $T_d \approx T - \frac{100 - RH}{5}$  represent the temperature at which the air would become saturated if cooled at constant pressure. The change in dewpoint across the day (`dewpoint_change`) measures whether the atmosphere is gaining or losing moisture over the course of the day, a signal not directly recoverable from temperature or humidity alone. The `moisture_index` encodes the combined effect of high humidity and limited solar exposure. The `instability_index` combines pressure deficit from the standard 1020 hPa baseline with humidity, approximating the atmospheric conditions that favour convective development. `cloud_development` captures upward cloud formation during the day, which the pressure analysis identified as a meaningful precursor to precipitation.

### Circular Wind Vector Decomposition

Wind direction is a circular variable: 360 $^\circ$  and 0 $^\circ$ represent the same direction (due North), yet a naive numeric encoding would treat them as maximally distant. This misrepresentation is particularly consequential for wind because the directional origin of an air mass carries meaningful physical content, moisture-laden northerly flows behave very differently from dry southerly flows in the Australian context.

The standard solution is to decompose each directional reading into orthogonal Cartesian components by projecting the wind vector onto the north-south and east-west axes:

$$U_{EW} = v \cdot \sin(\theta), \quad V_{NS} = v \cdot \cos(\theta)$$

where $v$ is wind speed (in km/h) and $\theta$ is the compass bearing in radians. The resulting U and V components are continuous and interpretable: a purely northerly wind of 20 km/h produces $V_{NS} = 20$, $U_{EW} = 0$; a purely easterly wind of the same speed produces $V_{NS} = 0$, $U_{EW} = 20$. This transformation is applied to both the peak gust and the 9:00 AM wind observations, yielding four wind component features in total.

---

## Multicollinearity Diagnostics

```{r}
#| label: multicollinearity-check
#| echo: true
#| message: false
#| warning: false

write_csv(df_final, "data/df_engineered.csv")

df_wo_location <- select_model_features(df_final, keep_location = FALSE)

vif_results <- mc_check(df_wo_location)

vif_results %>%
  as_tibble() %>%
  arrange(desc(VIF)) %>%
  kable(
    caption = "Variance Inflation Factor (VIF) for Selected Predictors",
    digits = 3
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)

df_scaled <- df_wo_location %>%
  scale_data()

write_csv(df_scaled, "data/df_scaled.csv")
```

Feature engineering that introduces interaction terms, composite indices, and temporal aggregates necessarily creates new correlational structure in the design matrix. After constructing the full feature set, it is therefore essential to verify that no predictor has become so collinear with the others that its coefficient in a linear model would be effectively unidentifiable. We use the Variance Inflation Factor (VIF) for this diagnosis. The VIF for a given predictor quantifies how much its coefficient variance is inflated relative to what it would be in an orthogonal design: a VIF of $k$ indicates that the standard error of that coefficient is $\sqrt{k}$ times larger than it would be if the predictor were uncorrelated with all others. Values above 10 are conventionally treated as indicating severe collinearity requiring remediation.

**Cyclical and wind components.** The `day_sin`, `day_cos`, `gust_V_NS`, and `gust_U_EW` features all show VIF values well below 3. This confirms that the decomposition strategies, sine/cosine for the annual cycle and U/V projection for wind direction, successfully converted circular variables into continuous representations without introducing redundancy. Each component carries information that is approximately orthogonal to its pair.

**Interaction stability.** The `sun_humid_interaction` term has a VIF of 1.188, which is exceptionally low for a multiplicative interaction. Without mean-centring the constituent variables before multiplication, interaction terms routinely exhibit VIFs above 10 due to their algebraic overlap with the main effects. The observed value of 1.188 provides empirical confirmation that centring eliminated this artificial correlation, and that the interaction term is capturing a genuinely distinct dimension of the feature space, the joint "Rain Corner" structure identified in the EDA.

**Elevated collinearity in humidity.** The highest observed VIF is for `humidity3pm` at approximately 4.832. This is expected: humidity participates structurally in three of the derived features (`moisture_index`, `instability_index`, and `sun_humid_interaction`), and its 7-day moving average is also present in the feature set. A VIF of 5 lies below the conventional threshold of 10 for severe concern and is consistent with what the literature describes as moderate collinearity. The decision to retain `humidity3pm` despite this inflation is deliberate: it is the single strongest individual predictor of rainfall in the dataset (Spearman $r = 0.44$, as established in the @sec-eda), and removing it in favour of its derived aggregates would sacrifice the direct same-day atmospheric moisture signal for the sake of a marginal improvement in collinearity. For tree-based models, this trade-off does not arise, since these methods are not sensitive to multicollinearity by design.

**Overall assessment.** The full engineered feature set is numerically stable for use in linear model families. No VIF exceeds the critical threshold of 10, and the majority of features show values below 3. The pipeline has successfully converted the raw meteorological signals into a representation that is both physically interpretable and statistically well-conditioned for the modelling stage.